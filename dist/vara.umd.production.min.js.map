{"version":3,"file":"vara.umd.production.min.js","sources":["../src/utils/constants.ts","../src/types.ts","../src/utils/renderbase.ts","../src/utils/letterpart.ts","../src/utils/letter.ts","../src/utils/line.ts","../src/utils/block.ts","../src/utils/char.ts","../src/utils/renderitem.ts","../src/index.ts"],"sourcesContent":["export const SCALEBASE = 16;\r\nexport const WHITESPACE = 10;","import Block from \"./utils/block\";\r\nimport Letter from \"./utils/letter\";\r\nimport LetterPart from \"./utils/letterpart\";\r\nimport Line from \"./utils/line\";\r\nimport RenderItem from \"./utils/renderitem\";\r\n\r\nexport type VaraGeneralOptions = {\r\n    fontSize?: number;\r\n    strokeWidth?: number;\r\n    color?: string;\r\n    duration?: number;\r\n    textAlign?: 'left' | 'center' | 'right';\r\n    autoAnimation?: boolean;\r\n    queued?: boolean;\r\n    delay?: number;\r\n    letterSpacing?:\r\n        | {\r\n              [x: string]: number;\r\n          }\r\n        | number;\r\n    breakWord?: boolean;\r\n    width?: number;\r\n    lineHeight?: number;\r\n};\r\n\r\nexport type VaraTextOptions = VaraGeneralOptions & {\r\n    id?: string | number | false;\r\n    x?: number;\r\n    y?: number;\r\n    absolutePosition?: boolean;\r\n};\r\n\r\nexport type VaraText = VaraTextOptions & {\r\n    text: string | string[];\r\n};\r\n\r\nexport type RenderData = RenderItem[];\r\n\r\nexport type VaraFontItem = {\r\n    paths: Array<{\r\n        w: number;\r\n        h: number;\r\n        my: number;\r\n        mx: number;\r\n        dx: number;\r\n        d: string;\r\n        pl: number;\r\n    }>;\r\n    w: number;\r\n};\r\n\r\nexport type ObjectKeys<T> = T extends object\r\n    ? (keyof T)[]\r\n    : T extends number\r\n    ? []\r\n    : T extends Array<any> | string\r\n    ? string[]\r\n    : never;\r\n\r\nexport const BLOCK_COMPOSITION = [\"block\",\"line\",\"letter\",\"letterPart\"] as const;\r\n\r\nexport type BlockComposition = typeof BLOCK_COMPOSITION;\r\n\r\nexport type BlockName = BlockComposition[number];\r\n\r\nexport type Blocks = Block | Line | Letter | LetterPart;\r\n\r\nexport type BlockMapped = {\r\n    \"block\" : Block,\r\n    \"line\": Line,\r\n    \"letter\": Letter,\r\n    \"letterPart\": LetterPart\r\n}","import { BlockMapped, BlockName, Blocks, BLOCK_COMPOSITION } from '../types';\r\n\r\ninterface RenderItemProps {\r\n    ctx: CanvasRenderingContext2D;\r\n    parent?: Blocks;\r\n}\r\n\r\nexport default class RenderBase {\r\n    ctx: CanvasRenderingContext2D;\r\n    parent?: Blocks | null;\r\n    name: BlockName;\r\n\r\n    constructor(props: RenderItemProps) {\r\n        this.ctx = props.ctx;\r\n        this.parent = props.parent ?? null;\r\n        this.name = 'block';\r\n    }\r\n\r\n    getParent<T extends BlockName>(parentName: T, current: Blocks): BlockMapped[T] | false {\r\n        const parentIndex = BLOCK_COMPOSITION.indexOf(parentName);\r\n        const currentItemIndex = BLOCK_COMPOSITION.indexOf(this.name);\r\n        if (parentIndex < currentItemIndex) {\r\n            if (current.name === parentName) {\r\n                return current as BlockMapped[T];\r\n            } else {\r\n                if (current.parent)\r\n                    return this.getParent(parentName, current?.parent);\r\n                else return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","import { BlockName } from '../types';\r\nimport Block from './block';\r\nimport Letter from './letter';\r\nimport RenderBase from './renderbase';\r\n\r\nexport interface LetterPartProps {\r\n    x: number;\r\n    y: number;\r\n    path: string;\r\n    pathLength: number;\r\n    dashOffset: number;\r\n    width: number;\r\n    ctx: CanvasRenderingContext2D;\r\n    parent: Letter;\r\n}\r\n\r\nexport default class LetterPart extends RenderBase {\r\n    x: number;\r\n    y: number;\r\n    path: string;\r\n    pathLength: number;\r\n    dashOffset: number;\r\n    width: number;\r\n    name: BlockName;\r\n    rootBlock: Block;\r\n\r\n    constructor(props: LetterPartProps) {\r\n        super(props);\r\n\r\n        this.x = props.x;\r\n        this.y = props.y;\r\n        this.path = props.path;\r\n        this.pathLength = props.pathLength;\r\n        this.dashOffset = props.dashOffset;\r\n        this.width = props.width;\r\n\r\n        this.name = 'letterPart';\r\n\r\n        this.rootBlock = this.getParent('block', this) as Block;\r\n    }\r\n\r\n    /**\r\n     * Paints the path\r\n     */\r\n    paint() {\r\n        // console.log(this.x,this.y);\r\n        this.ctx.save();\r\n        this.ctx.stroke(\r\n            new Path2D(this.processPath(this.path, this.x, this.y))\r\n        );\r\n        this.ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Increments the dashOffset and then paints the path.\r\n     */\r\n    draw(delta: number) {\r\n        const pathDuration =\r\n            ((this.pathLength / this.rootBlock.totalPathLength) *\r\n                this.rootBlock.options.duration) /\r\n            1000;\r\n\r\n        const speed = this.pathLength / pathDuration;\r\n\r\n        this.ctx.save();\r\n        this.ctx.lineDashOffset = 1;\r\n        this.ctx.setLineDash([this.dashOffset, this.pathLength + 1]);\r\n        this.dashOffset += speed * delta;\r\n        this.paint();\r\n        this.ctx.restore();\r\n    }\r\n\r\n    processPath(path: string, x = 0, y = 0) {\r\n        let svgPath = path.split('');\r\n        svgPath[2] = x + '';\r\n        svgPath[4] = y + '';\r\n        return svgPath.join('');\r\n    }\r\n}\r\n","import { BlockName } from \"../types\";\r\nimport Block from \"./block\";\r\nimport VaraChar from \"./char\";\r\nimport LetterPart, { LetterPartProps } from \"./letterpart\";\r\nimport Line from \"./line\";\r\nimport RenderBase from \"./renderbase\";\r\n\r\nexport interface LetterProps {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    ctx: CanvasRenderingContext2D;\r\n    parent: Line;\r\n    character: VaraChar;\r\n}\r\n\r\nexport default class Letter extends RenderBase {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    character: VaraChar;\r\n\r\n    parts: LetterPart[];\r\n\r\n    drawnParts: LetterPart[];\r\n    name: BlockName;\r\n\r\n    rootBlock: Block;\r\n\r\n    constructor(props: LetterProps) {\r\n        super(props);\r\n\r\n        this.x = props.x;\r\n        this.y = props.y;\r\n        this.width = props.width;\r\n        this.parts = [];\r\n        this.drawnParts = [];\r\n        this.name = \"letter\"\r\n\r\n        this.character = props.character;\r\n\r\n        this.rootBlock = this.getParent(\"block\", this) as Block;\r\n    }\r\n\r\n    setPosition(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    /**\r\n     * Add a new part to the queue\r\n     * @param part The part to be added\r\n     */\r\n    addPart(part: Omit<LetterPartProps,\"ctx\"|\"parent\">) {\r\n        this.parts.push(new LetterPart({\r\n            ...part,\r\n            ctx: this.ctx,\r\n            parent: this,\r\n        }));\r\n    \r\n        \r\n        // Update the total path length stored in the main block.\r\n        if(this.rootBlock){\r\n            this.rootBlock.modifyPathLength(part.pathLength, \"increment\");\r\n        }\r\n    }\r\n\r\n    isDone() {\r\n        return this.parts.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Remove the first item from the queue. Used when a part has been drawn completely.\r\n     * \r\n     * The removed item is moved to the drawnParts array\r\n     */\r\n    dequeue() {\r\n        const removedItem = this.parts.shift();\r\n        if (removedItem) this.drawnParts.push(removedItem);\r\n    }\r\n\r\n    /**\r\n     * Render the current letter\r\n     * @param rafTime The time value received from requestAnimationFrame\r\n     */\r\n    render(rafTime: number, previousRAFTime: number) {\r\n\r\n        this.ctx.save();\r\n        this.ctx.scale(this.rootBlock.scale, this.rootBlock.scale);\r\n        this.ctx.translate(this.x, this.y);\r\n\r\n        const delta = (rafTime - previousRAFTime) / 1000;\r\n\r\n        if (this.parts.length > 0) {\r\n            const part = this.parts[0];\r\n            if (part.dashOffset > part.pathLength) {\r\n                this.dequeue();\r\n            } else {\r\n                part.draw(delta);\r\n            }\r\n        }\r\n\r\n        this.drawnParts.forEach(drawnPart => {\r\n            drawnPart.paint();\r\n        })\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n\r\n    /**\r\n     * Paints the paths whose animations are complete\r\n     */\r\n    paint() {\r\n        this.ctx.save();\r\n        this.ctx.scale(this.rootBlock.scale,this.rootBlock.scale);\r\n        this.ctx.translate(this.x, this.y);\r\n\r\n        this.drawnParts.forEach(drawnPart => {\r\n            drawnPart.paint();\r\n        })\r\n\r\n        this.ctx.restore();\r\n    }\r\n}","import { BlockName } from \"../types\";\r\nimport Block from \"./block\";\r\nimport Letter, { LetterProps } from \"./letter\";\r\nimport RenderBase from \"./renderbase\";\r\n\r\nexport interface LineProps {\r\n    x: number;\r\n    y: number;\r\n    ctx: CanvasRenderingContext2D;\r\n    parent: Block;\r\n}\r\n\r\nexport default class Line extends RenderBase {\r\n    x: number;\r\n    y: number;\r\n    ctx: CanvasRenderingContext2D;\r\n    letters: Letter[];\r\n    _letters: Letter[];\r\n    drawnLetters: Letter[];\r\n    name: BlockName;\r\n\r\n    constructor(props: LineProps) {\r\n        super(props);\r\n\r\n        this.x = props.x;\r\n        this.y = props.y;\r\n        this.ctx = props.ctx;\r\n        this.letters = [];\r\n        this._letters = [];\r\n        this.drawnLetters = [];\r\n        this.name = \"line\";\r\n    }\r\n\r\n    addLetter(letter: Omit<LetterProps, \"ctx\"|\"parent\"> & { parent?: Line}) {\r\n        const newLetter = new Letter({\r\n            ...letter,\r\n            parent: letter.parent ?? this,\r\n            ctx: this.ctx\r\n        })\r\n\r\n        letter.character.getFontItem().paths.forEach(path => {\r\n            newLetter.addPart({\r\n                path: path.d,\r\n                x: path.mx - path.dx,\r\n                y: -path.my,\r\n                pathLength: path.pl,\r\n                dashOffset: 0,\r\n                width: path.w,\r\n            });\r\n        })\r\n        this.letters.push(newLetter);\r\n        this._letters.push(newLetter);\r\n\r\n        return newLetter;\r\n    }\r\n\r\n    setLetters(letters: Letter[]) {\r\n        this._letters = letters;\r\n        this.letters = letters.filter(letter => !letter.isDone());\r\n        this.drawnLetters = letters.filter(letter => letter.isDone());\r\n    }\r\n\r\n    generateLetter(letter: Omit<LetterProps, \"ctx\"|\"parent\">) {\r\n        const newLetter = new Letter({\r\n            ...letter,\r\n            parent: this,\r\n            ctx: this.ctx\r\n        })\r\n        return newLetter;\r\n    }\r\n\r\n    setPosition(x:number, y:number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    isDone(){\r\n        return this.letters.length === 0;\r\n    }\r\n\r\n    getAllLetters(){\r\n        return this._letters;\r\n    }\r\n\r\n    /**\r\n     * Remove the first item from the queue. Used when a letter has been drawn completely.\r\n     * The removed item is moved to the drawnLetters array\r\n     */\r\n    dequeue() {\r\n        const removedItem = this.letters.shift();\r\n        if (removedItem) this.drawnLetters.push(removedItem);\r\n    }\r\n\r\n    /**\r\n     * Render the current line\r\n     * @param rafTime The time value received from requestAnimationFrame\r\n     */\r\n    render(rafTime: number, prevRAFTime: number){\r\n        this.ctx.save();\r\n        this.ctx.translate(this.x, this.y);\r\n\r\n        if(this.letters.length > 0) {\r\n            const currentLetter = this.letters[0];\r\n            currentLetter.render(rafTime, prevRAFTime);\r\n\r\n            if(currentLetter.parts.length === 0) {\r\n                this.dequeue();\r\n            }\r\n        }\r\n\r\n        this.drawnLetters.forEach(letter => {\r\n            letter.paint();\r\n        })\r\n\r\n        this.ctx.restore();\r\n    }\r\n}","import { BlockName, VaraText } from '../types';\r\nimport { SCALEBASE } from './constants';\r\nimport Line, { LineProps } from './line';\r\nimport RenderBase from './renderbase';\r\n\r\ninterface BlockProps {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    ctx: CanvasRenderingContext2D;\r\n    options: Required<VaraText>;\r\n}\r\n\r\nexport default class Block extends RenderBase {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    scale: number;\r\n\r\n    ctx: CanvasRenderingContext2D;\r\n    previousRAFTime: number;\r\n    lines: Line[];\r\n    _lines: Line[];\r\n    drawnLines: Line[];\r\n    totalPathLength: number;\r\n    options: Required<VaraText>;\r\n\r\n    name: BlockName;\r\n\r\n    constructor(props: BlockProps) {\r\n        super(props);\r\n\r\n        this.x = props.x;\r\n        this.y = props.y;\r\n        this.width = props.width;\r\n\r\n        this.lines = [];\r\n        this._lines = [];\r\n        this.drawnLines = [];\r\n        this.ctx = props.ctx;\r\n        this.previousRAFTime = 0;\r\n        this.totalPathLength = 0;\r\n        this.options = props.options;\r\n\r\n        this.name = 'block';\r\n\r\n        this.scale = props.options.fontSize / SCALEBASE;\r\n    }\r\n\r\n    /**\r\n     * Creates and adds a new line of text\r\n     * @param line The properties of the line to be added\r\n     */\r\n    addLine(line: Omit<LineProps, 'ctx' | 'parent'>) {\r\n        const newLine = new Line({\r\n            ...line,\r\n            ctx: this.ctx,\r\n            parent: this,\r\n        });\r\n\r\n        this.lines.push(newLine);\r\n        this._lines.push(newLine);\r\n\r\n        return newLine;\r\n    }\r\n\r\n    getAllLetters() {\r\n        const letters = this._lines.map(item => item._letters);\r\n        return letters.flat();\r\n    } \r\n\r\n\r\n    getLetterById(id: number) {\r\n        return this.getAllLetters().find(item => item.character.id === id) ?? false;\r\n    }\r\n\r\n    /**\r\n     * Remove the first item from the queue. Used when a text line has been drawn completely.\r\n     * \r\n     * The removed item is moved to the drawnParts array\r\n     */\r\n    dequeue() {\r\n        const removedItem = this.lines.shift();\r\n        if (removedItem) this.lines.push(removedItem);\r\n    }\r\n\r\n    /**\r\n     * Increment or decrement the total path length\r\n     * @param pathLength Path length that is to be incremented or decrement\r\n     * @param action Whether to increment or decrement\r\n     */\r\n    modifyPathLength(\r\n        pathLength: number,\r\n        action: 'increment' | 'decrement' = 'increment'\r\n    ) {\r\n        if (action === 'increment') {\r\n            this.totalPathLength += pathLength;\r\n        } else {\r\n            this.totalPathLength -= pathLength;\r\n        }\r\n        return this.totalPathLength;\r\n    }\r\n\r\n    /**\r\n     * Render the block\r\n     * @param rafTime The time value received from requestAnimationFrame\r\n     */\r\n    render(rafTime: number) {\r\n        if (this.previousRAFTime === 0) {\r\n            this.previousRAFTime = rafTime;\r\n        }\r\n\r\n        this.ctx.save();\r\n        this.ctx.strokeStyle = this.options.color;\r\n        this.ctx.lineWidth = this.options.strokeWidth;\r\n        this.ctx.lineCap = 'round';\r\n        this.ctx.lineJoin = 'round';\r\n\r\n\r\n        this.drawnLines.forEach(line => {\r\n            line.render(rafTime, this.previousRAFTime);\r\n        });\r\n\r\n        if(this.lines.length > 0) {\r\n            const line = this.lines[0];\r\n            line.render(rafTime, this.previousRAFTime);\r\n            if(line.letters.length === 0) {\r\n                this.dequeue();\r\n            }\r\n        }\r\n        this.ctx.restore();\r\n\r\n        this.previousRAFTime = rafTime;\r\n    }\r\n}\r\n","import { VaraFontItem } from \"../types\";\r\n\r\ninterface VaraCharProps {\r\n    char: string;\r\n    fontItem: VaraFontItem;\r\n    isSpace?: boolean;\r\n}\r\n\r\nlet ___varaCharId___ = 0;\r\n\r\nexport default class VaraChar {\r\n    char: string;\r\n    id: number;\r\n    fontItem: VaraFontItem;\r\n    isSpace: boolean;\r\n\r\n    constructor(props:VaraCharProps) {\r\n        this.char = props.char;\r\n        this.fontItem = props.fontItem;\r\n        this.isSpace = props.isSpace ?? false;\r\n\r\n        this.id = ___varaCharId___;\r\n        ___varaCharId___++;\r\n    }\r\n\r\n    getFontItem() {\r\n        return this.fontItem;\r\n    }\r\n\r\n    getId() {\r\n        return this.id;\r\n    }\r\n}","import { VaraFontItem, VaraText, VaraTextOptions } from '../types';\r\nimport Block from './block';\r\nimport VaraChar from './char';\r\nimport { SCALEBASE, WHITESPACE } from './constants';\r\nimport Letter from './letter';\r\nimport Line from './line';\r\n\r\ninterface RenderItemProps {\r\n    textItem: VaraText;\r\n    options: Required<VaraTextOptions>;\r\n    fontCharacters: {\r\n        [x: string]: VaraFontItem;\r\n    };\r\n    ctx: CanvasRenderingContext2D;\r\n}\r\n\r\nexport default class RenderItem {\r\n    textItem: Required<VaraText>;\r\n    fontCharacters: {\r\n        [x: string]: VaraFontItem;\r\n    };\r\n    ctx: CanvasRenderingContext2D;\r\n    block: Block | null;\r\n    height: number;\r\n    text: VaraChar[][];\r\n\r\n    constructor(props: RenderItemProps) {\r\n        this.textItem = {\r\n            ...props.options,\r\n            ...props.textItem,\r\n        };\r\n        this.height = 0;\r\n        this.fontCharacters = props.fontCharacters;\r\n        this.ctx = props.ctx;\r\n        this.block = null;\r\n\r\n        if (typeof this.textItem.text === 'string') {\r\n            this.text = [\r\n                this.textItem.text.split('').map(\r\n                    letter =>\r\n                        new VaraChar({\r\n                            char: letter,\r\n                            fontItem:\r\n                                this.fontCharacters[letter.charCodeAt(0)] ||\r\n                                this.fontCharacters['63'],\r\n                            isSpace: letter === ' ',\r\n                        })\r\n                ),\r\n            ];\r\n        } else if (Array.isArray(this.textItem.text)) {\r\n            this.text = this.textItem.text.map(line =>\r\n                line.split('').map(\r\n                    letter =>\r\n                        new VaraChar({\r\n                            char: letter,\r\n                            fontItem:\r\n                                this.fontCharacters[letter.charCodeAt(0)] ||\r\n                                this.fontCharacters['63'],\r\n                            isSpace: letter === ' ',\r\n                        })\r\n                )\r\n            );\r\n        } else {\r\n            // TODO: Show warning / error\r\n            this.text = [];\r\n        }\r\n    }\r\n\r\n    addLetter({\r\n        letter,\r\n        position,\r\n    }: {\r\n        letter: string;\r\n        position: number | number[];\r\n    }) {\r\n        // let textBlock: string[] = [];\r\n        // if (Array.isArray(position) && Array.isArray(this.textItem.text)) {\r\n        //     textBlock[position[0]] = `${this.textItem.text[position[0]].slice(\r\n        //         0,\r\n        //         position[1]\r\n        //     )}${letter}${this.textItem.text[position[0]].slice(position[1])}`;\r\n        // } else {\r\n        //     if (typeof position === 'number') {\r\n        //         textBlock = [\r\n        //             `${this.textItem.text+\" \".slice(\r\n        //                 0,\r\n        //                 position\r\n        //             )}${letter}${this.textItem.text+\" \".slice(position)}`,\r\n        //         ];\r\n        //     }\r\n        // }\r\n\r\n        if (typeof position === 'number') {\r\n            let textCharCount = 0;\r\n            this.text.forEach((textLine, index) => {\r\n                console.log(textLine, position);\r\n                if (position <= textCharCount + textLine.length) {\r\n                    console.log(\"Here\");\r\n                    console.log(\"Before\", JSON.parse(JSON.stringify(this.text[index])));\r\n                    this.text[index] = [\r\n                        ...textLine.slice(0, position - textCharCount),\r\n                        new VaraChar({\r\n                            char: letter,\r\n                            fontItem:\r\n                                this.fontCharacters[letter.charCodeAt(0)] ||\r\n                                this.fontCharacters['63'],\r\n                            isSpace: letter === ' ',\r\n                        }),\r\n                        ...textLine.slice(position - textCharCount),\r\n                    ];\r\n                    console.log(\"After\", JSON.parse(JSON.stringify(this.text[index])));\r\n                } else {\r\n                    textCharCount += textLine.length;\r\n                }\r\n            });\r\n        }\r\n\r\n        this.regeneratePositions();\r\n    }\r\n\r\n    regeneratePositions() {\r\n        console.log(this.block);\r\n        let scale = this.textItem.fontSize / SCALEBASE;\r\n        this.height = 0;\r\n\r\n        const lines = this.generateLineData(this.text);\r\n\r\n        let top = this.textItem.lineHeight;\r\n\r\n        const block = this.block as Block;\r\n\r\n        if (lines.length > block._lines.length) {\r\n            while (lines.length > block._lines.length) {\r\n                block.addLine({\r\n                    x: 0,\r\n                    y: 0,\r\n                });\r\n            }\r\n        }\r\n\r\n        lines.forEach((line, lineIndex) => {\r\n            let left = 0;\r\n            let x = 0,\r\n                y = top;\r\n            if (this.textItem.textAlign === 'center') {\r\n                x = (this.textItem.width - line.width) / 2;\r\n            }\r\n\r\n            let lineClass = block.lines[lineIndex];\r\n            lineClass.setPosition(x, y);\r\n            const lettersToSet: Letter[] = [];\r\n\r\n            line.text.forEach(letter => {\r\n                if (letter.isSpace) {\r\n                    left += WHITESPACE;\r\n                } else {\r\n                    let foundLetter = block.getLetterById(letter.id);\r\n                    if (foundLetter) {\r\n                        foundLetter.parent = lineClass;\r\n                        foundLetter.setPosition(left, top);\r\n                        lettersToSet.push(foundLetter);\r\n                        left += foundLetter.character.getFontItem().w;\r\n                    } else {\r\n                        lettersToSet.push(\r\n                            lineClass.addLetter({\r\n                                character: letter,\r\n                                width: letter.getFontItem().w,\r\n                                x: left,\r\n                                y: top,\r\n                            })\r\n                        );\r\n                        left += letter.getFontItem().w;\r\n                    }\r\n                }\r\n            });\r\n            top += this.textItem.lineHeight;\r\n            this.height += this.textItem.lineHeight * scale;\r\n\r\n            lineClass.setLetters(lettersToSet);\r\n\r\n            console.log(lettersToSet);\r\n        });\r\n    }\r\n\r\n    generatePositions() {\r\n        let scale = this.textItem.fontSize / SCALEBASE;\r\n        this.height = 0;\r\n\r\n        const lines = this.generateLineData(this.text);\r\n\r\n        let top = this.textItem.lineHeight;\r\n\r\n        const block = new Block({\r\n            width: this.textItem.width,\r\n            x: this.textItem.x,\r\n            y: this.textItem.y,\r\n            ctx: this.ctx,\r\n            options: this.textItem,\r\n        });\r\n\r\n        lines.forEach(line => {\r\n            let left = 0;\r\n            let x = 0,\r\n                y = top;\r\n            if (this.textItem.textAlign === 'center') {\r\n                x = (this.textItem.width - line.width) / 2;\r\n            }\r\n\r\n            const lineClass = block.addLine({\r\n                x,\r\n                y,\r\n            });\r\n\r\n            line.text.forEach(letter => {\r\n                if (letter.isSpace) {\r\n                    left += WHITESPACE;\r\n                } else {\r\n                    const currentLetter = letter.getFontItem();\r\n\r\n                    lineClass.addLetter({\r\n                        x: left,\r\n                        y: top,\r\n                        width: currentLetter.w,\r\n                        character: letter,\r\n                    });\r\n\r\n                    left += currentLetter.w;\r\n                }\r\n            });\r\n            top += this.textItem.lineHeight;\r\n            this.height += this.textItem.lineHeight * scale;\r\n        });\r\n\r\n        this.block = block;\r\n    }\r\n\r\n    generateLineData(lines: VaraChar[][]) {\r\n        let scale = this.textItem.fontSize / SCALEBASE;\r\n\r\n        const returnData: {\r\n            text: VaraChar[];\r\n            width: number;\r\n        }[] = [\r\n            {\r\n                text: [],\r\n                width: 0,\r\n            },\r\n        ];\r\n\r\n        const wordSplittedLines: VaraChar[][][] = [];\r\n\r\n        lines.forEach(line => {\r\n            let l: VaraChar[][] = [[]];\r\n            line.forEach(letter => {\r\n                if (letter.isSpace) {\r\n                    l.push([]);\r\n                } else {\r\n                    l[l.length - 1].push(letter);\r\n                }\r\n            });\r\n            wordSplittedLines.push(l);\r\n        });\r\n\r\n        wordSplittedLines.forEach(line => {\r\n            let spaceWidth = 0;\r\n            line.forEach(word => {\r\n                let wordWidth = 0;\r\n\r\n                word.forEach(letter => {\r\n                    const currentLetter = letter.getFontItem();\r\n\r\n                    let pathPositionCorrection = currentLetter.paths.reduce(\r\n                        (a, c) => a + c.mx - c.dx,\r\n                        0\r\n                    );\r\n                    wordWidth +=\r\n                        (currentLetter.w + pathPositionCorrection) * scale;\r\n                });\r\n\r\n                if (\r\n                    (returnData[lines.length - 1]?.width ?? 0) +\r\n                        wordWidth +\r\n                        5 * scale +\r\n                        spaceWidth +\r\n                        this.textItem.x * scale >\r\n                    this.textItem.width\r\n                ) {\r\n                    returnData.push({\r\n                        text: [\r\n                            ...word,\r\n                            new VaraChar({\r\n                                char: ' ',\r\n                                fontItem: this.fontCharacters['63'],\r\n                                isSpace: true,\r\n                            }),\r\n                        ],\r\n                        width: wordWidth,\r\n                    });\r\n                    spaceWidth = 0;\r\n                } else {\r\n                    returnData[returnData.length - 1] = {\r\n                        text: [\r\n                            ...returnData[returnData.length - 1].text,\r\n                            ...word,\r\n                            new VaraChar({\r\n                                char: ' ',\r\n                                fontItem: this.fontCharacters['63'],\r\n                                isSpace: true,\r\n                            }),\r\n                        ],\r\n                        width:\r\n                            returnData[returnData.length - 1].width + wordWidth,\r\n                    };\r\n                    spaceWidth += WHITESPACE * scale;\r\n                }\r\n            });\r\n        });\r\n\r\n        return returnData;\r\n    }\r\n\r\n    render(rafTime: number) {\r\n        if (this.block) {\r\n            this.block.render(rafTime);\r\n        }\r\n    }\r\n\r\n    rendered() {\r\n        return this.block?.lines.length === 0;\r\n    }\r\n}\r\n","import {\r\n    VaraGeneralOptions,\r\n    VaraText,\r\n    RenderData,\r\n    VaraFontItem,\r\n    ObjectKeys,\r\n    VaraTextOptions,\r\n} from './types';\r\nimport RenderItem from './utils/renderitem';\r\n\r\nexport default class Vara {\r\n    elementName: string;\r\n    element: HTMLElement;\r\n    fontSource: string;\r\n    options: VaraGeneralOptions;\r\n    textItems: VaraText[];\r\n    renderData: {\r\n        queued: RenderData;\r\n        nonQueued: RenderData;\r\n    };\r\n    rendered: boolean;\r\n    defaultOptions: Required<VaraGeneralOptions>;\r\n    defaultCharacters: {\r\n        [x: string]: VaraFontItem;\r\n    };\r\n    canvas: HTMLCanvasElement;\r\n    ctx: CanvasRenderingContext2D;\r\n    canvasWidth: number;\r\n    contextHeight: number;\r\n    fontCharacters: {\r\n        [x: string]: VaraFontItem;\r\n    };\r\n    fontProperties!: {\r\n        s: number;\r\n        // TODO: add other properties\r\n        slc: 'round';\r\n        bsw: number;\r\n        lh: number;\r\n        space: number;\r\n        tf: number;\r\n    };\r\n    onDrawF?: (fn?: Required<RenderData>) => void;\r\n    WHITESPACE: number;\r\n    SCALEBASE: number;\r\n\r\n    constructor(\r\n        elem: string,\r\n        fontSource: string,\r\n        text: VaraText[],\r\n        options: VaraGeneralOptions\r\n    ) {\r\n        this.elementName = elem;\r\n        this.element = document.querySelector(elem) as HTMLElement;\r\n        this.fontSource = fontSource;\r\n        this.options = options;\r\n        this.textItems = text;\r\n        this.renderData = {\r\n            nonQueued: [],\r\n            queued: [],\r\n        };\r\n        this.rendered = false;\r\n        this.fontCharacters = {};\r\n        this.canvasWidth = 0;\r\n\r\n        this.defaultOptions = {\r\n            fontSize: 21,\r\n            strokeWidth: 0.5,\r\n            color: '#000',\r\n            duration: 1000,\r\n            textAlign: 'left',\r\n            autoAnimation: true,\r\n            queued: true,\r\n            delay: 0,\r\n            breakWord: false,\r\n            letterSpacing: {\r\n                global: 0,\r\n            },\r\n            width: this.element.getBoundingClientRect().width,\r\n            lineHeight: 30,\r\n        };\r\n\r\n        this.defaultCharacters = {\r\n            '63': {\r\n                paths: [\r\n                    {\r\n                        w: 8.6437,\r\n                        h: 14.23173,\r\n                        my: 22.6665,\r\n                        mx: 0,\r\n                        dx: 0,\r\n                        d:\r\n                            'm 0,0 c -2,-6.01,5,-8.64,8,-3.98,2,4.09,-7,8.57,-7,11.85',\r\n                        pl: 1,\r\n                    },\r\n                    {\r\n                        w: 1.1037,\r\n                        h: 1.5498,\r\n                        my: 8.8815,\r\n                        dx: 0,\r\n                        mx: 1,\r\n                        d:\r\n                            'm 0,0 a 0.7592,0.7357,0,0,1,0,0.735,0.7592,0.7357,0,0,1,-1,-0.735,0.7592,0.7357,0,0,1,1,-0.738,0.7592,0.7357,0,0,1,0,0.738 z',\r\n                        pl: 1,\r\n                    },\r\n                ],\r\n                w: 8.6437,\r\n            },\r\n        };\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.width = this.element.getBoundingClientRect().width;\r\n        this.canvas.height = 800;\r\n        this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\r\n        this.element.appendChild(this.canvas);\r\n        this.WHITESPACE = 10;\r\n        this.SCALEBASE = 16;\r\n\r\n        this.contextHeight = 0;\r\n\r\n        this.init();\r\n    }\r\n\r\n    private init() {\r\n        this.normalizeOptions();\r\n\r\n        const xmlhttp = new XMLHttpRequest();\r\n        xmlhttp.open('GET', this.fontSource, true);\r\n        xmlhttp.onreadystatechange = () => {\r\n            if (xmlhttp.readyState == 4) {\r\n                if (xmlhttp.status == 200) {\r\n                    const contents = JSON.parse(xmlhttp.responseText);\r\n                    this.fontCharacters = contents.c;\r\n                    this.fontProperties = contents.p;\r\n                    this.preRender();\r\n                    this.render();\r\n                }\r\n            }\r\n        };\r\n        xmlhttp.send(null);\r\n    }\r\n\r\n    onDraw(fn: (a?: Required<RenderData>) => void) {\r\n        this.onDrawF = fn;\r\n    }\r\n\r\n    /**\r\n     * Sets default option value for all existing option properties.\r\n     * If an option value is not provided, then it will first check if it is given in the global options, if not it will use the default option.\r\n     */\r\n    private normalizeOptions() {\r\n        this.options = this.options || {};\r\n\r\n        this.options = {\r\n            ...this.defaultOptions,\r\n            ...this.options,\r\n        };\r\n\r\n        Object.keys(this.defaultCharacters).forEach(character => {\r\n            if (this.fontCharacters[character] === undefined) {\r\n                this.fontCharacters[character] = this.defaultCharacters[\r\n                    character\r\n                ];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Performs some actions before rendering starts. These include finding the pathLength of each path and generating the render data.\r\n     */\r\n    private preRender() {\r\n        let svg = this.createSVGNode('svg', {\r\n            width: '100',\r\n            height: '100',\r\n        });\r\n        svg.style.position = 'absolute';\r\n        svg.style.zIndex = '-100';\r\n        svg.style.opacity = '0';\r\n        svg.style.top = '0';\r\n\r\n        document.body.appendChild(svg);\r\n        let svgPathData = this.createSVGNode('path', {\r\n            d: '',\r\n        }) as SVGPathElement;\r\n        svg.appendChild(svgPathData);\r\n\r\n        this.objectKeys(this.fontCharacters).forEach(char => {\r\n            this.fontCharacters[char].paths.forEach((path, i) => {\r\n                svgPathData.setAttributeNS(null, 'd', path.d);\r\n                this.fontCharacters[char].paths[\r\n                    i\r\n                ].dx = svgPathData.getBoundingClientRect().x;\r\n                this.fontCharacters[char].paths[\r\n                    i\r\n                ].pl = svgPathData.getTotalLength();\r\n            });\r\n        });\r\n\r\n        this.textItems.forEach(item => {\r\n            const renderItem = new RenderItem({\r\n                fontCharacters: this.fontCharacters,\r\n                options: this.options as Required<VaraTextOptions>,\r\n                textItem: item,\r\n                ctx: this.ctx,\r\n            });\r\n\r\n            renderItem.generatePositions();\r\n\r\n            if (item.queued) {\r\n                this.renderData.queued.push(renderItem);\r\n            } else {\r\n                this.renderData.nonQueued.push(renderItem);\r\n            }\r\n        });\r\n    }\r\n\r\n    private render(rafTime = 0) {\r\n        let canvasHeight = this.calculateCanvasHeight();\r\n        if (canvasHeight !== this.canvas.height) {\r\n            this.canvas.height = canvasHeight;\r\n        }\r\n        this.ctx.clearRect(0, 0, this.canvas.width, canvasHeight);\r\n\r\n        this.renderData.nonQueued.forEach(item => {\r\n            item.render(rafTime);\r\n        });\r\n\r\n        if (this.renderData.queued.length > 0) {\r\n            const queueHead = this.renderData.queued[0];\r\n            queueHead.render(rafTime);\r\n            if (queueHead.rendered()) {\r\n                this.dequeue();\r\n            }\r\n        }\r\n\r\n        window.requestAnimationFrame(time => this.render(time));\r\n    }\r\n\r\n    /**\r\n     * Remove the first item from the queue. Used when a block has been drawn completely.\r\n     * The removed item is moved to the drawnLetters array\r\n     */\r\n    private dequeue() {\r\n        const removedItem = this.renderData.queued.shift();\r\n        if (removedItem) this.renderData.nonQueued.push(removedItem);\r\n    }\r\n\r\n    // TODO: Make proper calculation function.\r\n    calculateCanvasHeight() {\r\n        let height = 0;\r\n        [...this.renderData.nonQueued, ...this.renderData.queued].forEach(\r\n            item => {\r\n                if (item.height && item.textItem.y) {\r\n                    height += item.height + item.textItem.y;\r\n                }\r\n            }\r\n        );\r\n        return height + 50;\r\n    }\r\n\r\n    addLetter({\r\n        letter,\r\n        id,\r\n        position,\r\n    }: {\r\n        letter: string;\r\n        id: string;\r\n        position: number;\r\n    }) {\r\n        const block = [\r\n            ...this.renderData.nonQueued,\r\n            ...this.renderData.queued,\r\n        ].find(item => item.textItem.id === id);\r\n\r\n        console.log(letter, position);\r\n        block?.addLetter({ letter, position });\r\n        // if(block) {\r\n        //     block.\r\n        // }\r\n    }\r\n\r\n    /**\r\n     * Creates and returns an SVG element\r\n     * @param n The name of the SVG node to be created\r\n     * @param v The attributes of the node\r\n     */\r\n\r\n    createSVGNode(n: string, v: { [x: string]: string }) {\r\n        const e = document.createElementNS('http://www.w3.org/2000/svg', n);\r\n        for (var p in v)\r\n            e.setAttributeNS(\r\n                null,\r\n                p.replace(/[A-Z]/g, function(m) {\r\n                    return '-' + m.toLowerCase();\r\n                }),\r\n                v[p]\r\n            );\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Modifies the move to command of a given path and returns it.\r\n     * @param path The path \"d\" property\r\n     * @param x The x co-ordinate\r\n     * @param y The y co-ordinate\r\n     */\r\n    processPath(path: string, x = 0, y = 0) {\r\n        let svgPath = path.split('');\r\n        svgPath[2] = x + 1 + '';\r\n        svgPath[4] = y + '';\r\n        return svgPath.join('');\r\n    }\r\n\r\n    objectKeys<T>(x: T) {\r\n        let keys = Object.keys(x) as ObjectKeys<T>;\r\n        return keys;\r\n    }\r\n\r\n    boundRect(x: number, y: number, w: number, h = 10) {\r\n        this.ctx.save();\r\n        this.ctx.fillStyle = 'rgba(209, 56, 61,0.4)';\r\n        this.ctx.fillRect(x, y, w, h);\r\n        this.ctx.fill();\r\n        this.ctx.restore();\r\n    }\r\n}\r\n\r\nif (window) {\r\n    (<any>window).Vara = Vara;\r\n}\r\n"],"names":["BLOCK_COMPOSITION","RenderBase","props","ctx","parent","name","getParent","parentName","current","indexOf","this","LetterPart","x","y","path","pathLength","dashOffset","width","rootBlock","_this","paint","save","stroke","Path2D","processPath","restore","draw","delta","speed","totalPathLength","options","duration","lineDashOffset","setLineDash","svgPath","split","join","Letter","parts","drawnParts","character","setPosition","addPart","part","push","modifyPathLength","isDone","length","dequeue","removedItem","shift","render","rafTime","previousRAFTime","scale","translate","forEach","drawnPart","Line","letters","_letters","drawnLetters","addLetter","letter","newLetter","getFontItem","paths","d","mx","dx","my","pl","w","setLetters","filter","generateLetter","getAllLetters","prevRAFTime","currentLetter","Block","lines","_lines","drawnLines","fontSize","addLine","line","newLine","map","item","flat","getLetterById","id","find","action","strokeStyle","color","lineWidth","strokeWidth","lineCap","lineJoin","_this2","___varaCharId___","VaraChar","fontItem","isSpace","getId","RenderItem","textItem","height","fontCharacters","block","text","charCodeAt","Array","isArray","position","textCharCount","textLine","index","console","log","JSON","parse","stringify","slice","regeneratePositions","generateLineData","top","lineHeight","lineIndex","left","_this3","textAlign","lineClass","lettersToSet","foundLetter","generatePositions","_this4","returnData","wordSplittedLines","l","spaceWidth","word","wordWidth","pathPositionCorrection","reduce","a","c","_returnData","_this5","rendered","Vara","elem","fontSource","elementName","element","document","querySelector","textItems","renderData","nonQueued","queued","canvasWidth","defaultOptions","autoAnimation","delay","breakWord","letterSpacing","global","getBoundingClientRect","defaultCharacters","h","canvas","createElement","getContext","appendChild","WHITESPACE","SCALEBASE","contextHeight","init","normalizeOptions","xmlhttp","XMLHttpRequest","open","onreadystatechange","readyState","status","contents","responseText","fontProperties","p","preRender","send","onDraw","fn","onDrawF","Object","keys","undefined","svg","createSVGNode","style","zIndex","opacity","body","svgPathData","objectKeys","char","i","setAttributeNS","getTotalLength","renderItem","canvasHeight","calculateCanvasHeight","clearRect","queueHead","window","requestAnimationFrame","time","n","v","e","createElementNS","replace","m","toLowerCase","boundRect","fillStyle","fillRect","fill"],"mappings":"2mBAAO,IC2DMA,EAAoB,CAAC,QAAQ,OAAO,SAAS,cCpDrCC,wBAKLC,cACHC,IAAMD,EAAMC,SACZC,iBAASF,EAAME,sBAAU,UACzBC,KAAO,2BAGhBC,UAAA,SAA+BC,EAAeC,UACtBR,EAAkBS,QAAQF,GACrBP,EAAkBS,QAAQC,KAAKL,QAEhDG,EAAQH,OAASE,EACVC,IAEHA,EAAQJ,QACDM,KAAKJ,UAAUC,EAAYC,MAAAA,SAAAA,EAASJ,eCV1CO,yBAULT,8BACFA,UAEDU,EAAIV,EAAMU,IACVC,EAAIX,EAAMW,IACVC,KAAOZ,EAAMY,OACbC,WAAab,EAAMa,aACnBC,WAAad,EAAMc,aACnBC,MAAQf,EAAMe,QAEdZ,KAAO,eAEPa,UAAYC,EAAKb,UAAU,kDAMpCc,MAAA,gBAESjB,IAAIkB,YACJlB,IAAImB,OACL,IAAIC,OAAOb,KAAKc,YAAYd,KAAKI,KAAMJ,KAAKE,EAAGF,KAAKG,UAEnDV,IAAIsB,aAMbC,KAAA,SAAKC,OAMKC,EAAQlB,KAAKK,YAJbL,KAAKK,WAAaL,KAAKQ,UAAUW,gBAC/BnB,KAAKQ,UAAUY,QAAQC,SAC3B,UAIC5B,IAAIkB,YACJlB,IAAI6B,eAAiB,OACrB7B,IAAI8B,YAAY,CAACvB,KAAKM,WAAYN,KAAKK,WAAa,SACpDC,YAAcY,EAAQD,OACtBP,aACAjB,IAAIsB,aAGbD,YAAA,SAAYV,EAAcF,EAAOC,YAAPD,IAAAA,EAAI,YAAGC,IAAAA,EAAI,OAC7BqB,EAAUpB,EAAKqB,MAAM,WACzBD,EAAQ,GAAKtB,EAAI,GACjBsB,EAAQ,GAAKrB,EAAI,GACVqB,EAAQE,KAAK,QA5DYnC,GCAnBoC,yBAaLnC,8BACFA,UAEDU,EAAIV,EAAMU,IACVC,EAAIX,EAAMW,IACVI,MAAQf,EAAMe,QACdqB,MAAQ,KACRC,WAAa,KACblC,KAAO,WAEPmC,UAAYtC,EAAMsC,YAElBtB,UAAYC,EAAKb,UAAU,kDAGpCmC,YAAA,SAAY7B,EAAWC,QACdD,EAAIA,OACJC,EAAIA,KAOb6B,QAAA,SAAQC,QACCL,MAAMM,KAAK,IAAIjC,OACbgC,GACHxC,IAAKO,KAAKP,IACVC,OAAQM,SAKTA,KAAKQ,gBACCA,UAAU2B,iBAAiBF,EAAK5B,WAAY,gBAIzD+B,OAAA,kBACiC,IAAtBpC,KAAK4B,MAAMS,UAQtBC,QAAA,eACUC,EAAcvC,KAAK4B,MAAMY,QAC3BD,GAAavC,KAAK6B,WAAWK,KAAKK,MAO1CE,OAAA,SAAOC,EAAiBC,QAEflD,IAAIkB,YACJlB,IAAImD,MAAM5C,KAAKQ,UAAUoC,MAAO5C,KAAKQ,UAAUoC,YAC/CnD,IAAIoD,UAAU7C,KAAKE,EAAGF,KAAKG,OAE1Bc,GAASyB,EAAUC,GAAmB,OAExC3C,KAAK4B,MAAMS,OAAS,EAAG,KACjBJ,EAAOjC,KAAK4B,MAAM,GACpBK,EAAK3B,WAAa2B,EAAK5B,gBAClBiC,UAELL,EAAKjB,KAAKC,QAIbY,WAAWiB,SAAQ,SAAAC,GACpBA,EAAUrC,gBAGTjB,IAAIsB,aAObL,MAAA,gBACSjB,IAAIkB,YACJlB,IAAImD,MAAM5C,KAAKQ,UAAUoC,MAAM5C,KAAKQ,UAAUoC,YAC9CnD,IAAIoD,UAAU7C,KAAKE,EAAGF,KAAKG,QAE3B0B,WAAWiB,SAAQ,SAAAC,GACpBA,EAAUrC,gBAGTjB,IAAIsB,cA1GmBxB,GCJfyD,yBASLxD,8BACFA,UAEDU,EAAIV,EAAMU,IACVC,EAAIX,EAAMW,IACVV,IAAMD,EAAMC,MACZwD,QAAU,KACVC,SAAW,KACXC,aAAe,KACfxD,KAAO,2CAGhByD,UAAA,SAAUC,SACAC,EAAY,IAAI3B,OACf0B,GACH3D,iBAAQ2D,EAAO3D,sBAAUM,KACzBP,IAAKO,KAAKP,cAGd4D,EAAOvB,UAAUyB,cAAcC,MAAMV,SAAQ,SAAA1C,GACzCkD,EAAUtB,QAAQ,CACd5B,KAAMA,EAAKqD,EACXvD,EAAGE,EAAKsD,GAAKtD,EAAKuD,GAClBxD,GAAIC,EAAKwD,GACTvD,WAAYD,EAAKyD,GACjBvD,WAAY,EACZC,MAAOH,EAAK0D,YAGfb,QAAQf,KAAKoB,QACbJ,SAAShB,KAAKoB,GAEZA,KAGXS,WAAA,SAAWd,QACFC,SAAWD,OACXA,QAAUA,EAAQe,QAAO,SAAAX,UAAWA,EAAOjB,iBAC3Ce,aAAeF,EAAQe,QAAO,SAAAX,UAAUA,EAAOjB,eAGxD6B,eAAA,SAAeZ,UACO,IAAI1B,OACf0B,GACH3D,OAAQM,KACRP,IAAKO,KAAKP,UAKlBsC,YAAA,SAAY7B,EAAUC,QACbD,EAAIA,OACJC,EAAIA,KAGbiC,OAAA,kBACmC,IAAxBpC,KAAKiD,QAAQZ,UAGxB6B,cAAA,kBACWlE,KAAKkD,YAOhBZ,QAAA,eACUC,EAAcvC,KAAKiD,QAAQT,QAC7BD,GAAavC,KAAKmD,aAAajB,KAAKK,MAO5CE,OAAA,SAAOC,EAAiByB,WACf1E,IAAIkB,YACJlB,IAAIoD,UAAU7C,KAAKE,EAAGF,KAAKG,GAE7BH,KAAKiD,QAAQZ,OAAS,EAAG,KAClB+B,EAAgBpE,KAAKiD,QAAQ,GACnCmB,EAAc3B,OAAOC,EAASyB,GAEI,IAA/BC,EAAcxC,MAAMS,aACdC,eAIRa,aAAaL,SAAQ,SAAAO,GACtBA,EAAO3C,gBAGNjB,IAAIsB,cAtGiBxB,GCCb8E,yBAgBL7E,8BACFA,UAEDU,EAAIV,EAAMU,IACVC,EAAIX,EAAMW,IACVI,MAAQf,EAAMe,QAEd+D,MAAQ,KACRC,OAAS,KACTC,WAAa,KACb/E,IAAMD,EAAMC,MACZkD,gBAAkB,IAClBxB,gBAAkB,IAClBC,QAAU5B,EAAM4B,UAEhBzB,KAAO,UAEPiD,MAAQpD,EAAM4B,QAAQqD,SN9CV,uCMqDrBC,QAAA,SAAQC,OACEC,EAAU,IAAI5B,OACb2B,GACHlF,IAAKO,KAAKP,IACVC,OAAQM,oBAGPsE,MAAMpC,KAAK0C,QACXL,OAAOrC,KAAK0C,GAEVA,KAGXV,cAAA,kBACoBlE,KAAKuE,OAAOM,KAAI,SAAAC,UAAQA,EAAK5B,YAC9B6B,UAInBC,cAAA,SAAcC,0BACHjF,KAAKkE,gBAAgBgB,MAAK,SAAAJ,UAAQA,EAAKhD,UAAUmD,KAAOA,wBAQnE3C,QAAA,eACUC,EAAcvC,KAAKsE,MAAM9B,QAC3BD,GAAavC,KAAKsE,MAAMpC,KAAKK,MAQrCJ,iBAAA,SACI9B,EACA8E,mBAAAA,IAAAA,EAAoC,aAErB,cAAXA,OACKhE,iBAAmBd,OAEnBc,iBAAmBd,EAErBL,KAAKmB,mBAOhBsB,OAAA,SAAOC,iBAC0B,IAAzB1C,KAAK2C,uBACAA,gBAAkBD,QAGtBjD,IAAIkB,YACJlB,IAAI2F,YAAcpF,KAAKoB,QAAQiE,WAC/B5F,IAAI6F,UAAYtF,KAAKoB,QAAQmE,iBAC7B9F,IAAI+F,QAAU,aACd/F,IAAIgG,SAAW,aAGfjB,WAAW1B,SAAQ,SAAA6B,GACpBA,EAAKlC,OAAOC,EAASgD,EAAK/C,oBAG3B3C,KAAKsE,MAAMjC,OAAS,EAAG,KAChBsC,EAAO3E,KAAKsE,MAAM,GACxBK,EAAKlC,OAAOC,EAAS1C,KAAK2C,iBACC,IAAxBgC,EAAK1B,QAAQZ,aACPC,eAGR7C,IAAIsB,eAEJ4B,gBAAkBD,MAvHInD,GCL/BoG,EAAmB,EAEFC,wBAMLpG,mBACIA,YACPqG,SAAWrG,EAAMqG,cACjBC,kBAAUtG,EAAMsG,6BAEhBb,GAAKU,EACVA,+BAGJpC,YAAA,kBACWvD,KAAK6F,YAGhBE,MAAA,kBACW/F,KAAKiF,SCdCe,wBAULxG,mBACHyG,cACEzG,EAAM4B,QACN5B,EAAMyG,eAERC,OAAS,OACTC,eAAiB3G,EAAM2G,oBACvB1G,IAAMD,EAAMC,SACZ2G,MAAQ,UAGJC,KADyB,iBAAvBrG,KAAKiG,SAASI,KACT,CACRrG,KAAKiG,SAASI,KAAK5E,MAAM,IAAIoD,KACzB,SAAAxB,UACI,IAAIuC,EAAS,MACHvC,EACNwC,SACIpF,EAAK0F,eAAe9C,EAAOiD,WAAW,KACtC7F,EAAK0F,eAAe,IACxBL,QAAoB,MAAXzC,QAIlBkD,MAAMC,QAAQxG,KAAKiG,SAASI,MACvBrG,KAAKiG,SAASI,KAAKxB,KAAI,SAAAF,UAC/BA,EAAKlD,MAAM,IAAIoD,KACX,SAAAxB,UACI,IAAIuC,EAAS,MACHvC,EACNwC,SACIpF,EAAK0F,eAAe9C,EAAOiD,WAAW,KACtC7F,EAAK0F,eAAe,IACxBL,QAAoB,MAAXzC,UAMb,8BAIpBD,UAAA,uBACIC,IAAAA,OACAoD,IAAAA,YAsBwB,iBAAbA,EAAuB,KAC1BC,EAAgB,OACfL,KAAKvD,SAAQ,SAAC6D,EAAUC,GACzBC,QAAQC,IAAIH,EAAUF,GAClBA,GAAYC,EAAgBC,EAAStE,QACrCwE,QAAQC,IAAI,QACZD,QAAQC,IAAI,SAAUC,KAAKC,MAAMD,KAAKE,UAAUvB,EAAKW,KAAKO,MAC1DlB,EAAKW,KAAKO,aACHD,EAASO,MAAM,EAAGT,EAAWC,IAChC,IAAId,EAAS,MACHvC,EACNwC,SACIH,EAAKS,eAAe9C,EAAOiD,WAAW,KACtCZ,EAAKS,eAAe,IACxBL,QAAoB,MAAXzC,KAEVsD,EAASO,MAAMT,EAAWC,IAEjCG,QAAQC,IAAI,QAASC,KAAKC,MAAMD,KAAKE,UAAUvB,EAAKW,KAAKO,OAEzDF,GAAiBC,EAAStE,eAKjC8E,yBAGTA,oBAAA,sBACIN,QAAQC,IAAI9G,KAAKoG,WACbxD,EAAQ5C,KAAKiG,SAASxB,SR1HT,QQ2HZyB,OAAS,MAER5B,EAAQtE,KAAKoH,iBAAiBpH,KAAKqG,MAErCgB,EAAMrH,KAAKiG,SAASqB,WAElBlB,EAAQpG,KAAKoG,SAEf9B,EAAMjC,OAAS+D,EAAM7B,OAAOlC,YACrBiC,EAAMjC,OAAS+D,EAAM7B,OAAOlC,QAC/B+D,EAAM1B,QAAQ,CACVxE,EAAG,EACHC,EAAG,IAKfmE,EAAMxB,SAAQ,SAAC6B,EAAM4C,OACbC,EAAO,EACPtH,EAAI,EAEwB,WAA5BuH,EAAKxB,SAASyB,YACdxH,GAAKuH,EAAKxB,SAAS1F,MAAQoE,EAAKpE,OAAS,OAGzCoH,EAAYvB,EAAM9B,MAAMiD,GAC5BI,EAAU5F,YAAY7B,EANdmH,OAOFO,EAAyB,GAE/BjD,EAAK0B,KAAKvD,SAAQ,SAAAO,MACVA,EAAOyC,QACP0B,GRzJM,OQ0JH,KACCK,EAAczB,EAAMpB,cAAc3B,EAAO4B,IACzC4C,GACAA,EAAYnI,OAASiI,EACrBE,EAAY9F,YAAYyF,EAAMH,GAC9BO,EAAa1F,KAAK2F,GAClBL,GAAQK,EAAY/F,UAAUyB,cAAcO,IAE5C8D,EAAa1F,KACTyF,EAAUvE,UAAU,CAChBtB,UAAWuB,EACX9C,MAAO8C,EAAOE,cAAcO,EAC5B5D,EAAGsH,EACHrH,EAAGkH,KAGXG,GAAQnE,EAAOE,cAAcO,OAIzCuD,GAAOI,EAAKxB,SAASqB,WACrBG,EAAKvB,QAAUuB,EAAKxB,SAASqB,WAAa1E,EAE1C+E,EAAU5D,WAAW6D,GAErBf,QAAQC,IAAIc,SAIpBE,kBAAA,sBACQlF,EAAQ5C,KAAKiG,SAASxB,SRzLT,QQ0LZyB,OAAS,MAER5B,EAAQtE,KAAKoH,iBAAiBpH,KAAKqG,MAErCgB,EAAMrH,KAAKiG,SAASqB,WAElBlB,EAAQ,IAAI/B,EAAM,CACpB9D,MAAOP,KAAKiG,SAAS1F,MACrBL,EAAGF,KAAKiG,SAAS/F,EACjBC,EAAGH,KAAKiG,SAAS9F,EACjBV,IAAKO,KAAKP,IACV2B,QAASpB,KAAKiG,WAGlB3B,EAAMxB,SAAQ,SAAA6B,OACN6C,EAAO,EACPtH,EAAI,EAEwB,WAA5B6H,EAAK9B,SAASyB,YACdxH,GAAK6H,EAAK9B,SAAS1F,MAAQoE,EAAKpE,OAAS,OAGvCoH,EAAYvB,EAAM1B,QAAQ,CAC5BxE,EAAAA,EACAC,EAPIkH,IAUR1C,EAAK0B,KAAKvD,SAAQ,SAAAO,MACVA,EAAOyC,QACP0B,GRtNM,OQuNH,KACGpD,EAAgBf,EAAOE,cAE7BoE,EAAUvE,UAAU,CAChBlD,EAAGsH,EACHrH,EAAGkH,EACH9G,MAAO6D,EAAcN,EACrBhC,UAAWuB,IAGfmE,GAAQpD,EAAcN,MAG9BuD,GAAOU,EAAK9B,SAASqB,WACrBS,EAAK7B,QAAU6B,EAAK9B,SAASqB,WAAa1E,UAGzCwD,MAAQA,KAGjBgB,iBAAA,SAAiB9C,cACT1B,EAAQ5C,KAAKiG,SAASxB,SR7OT,GQ+OXuD,EAGA,CACF,CACI3B,KAAM,GACN9F,MAAO,IAIT0H,EAAoC,UAE1C3D,EAAMxB,SAAQ,SAAA6B,OACNuD,EAAkB,CAAC,IACvBvD,EAAK7B,SAAQ,SAAAO,GACLA,EAAOyC,QACPoC,EAAEhG,KAAK,IAEPgG,EAAEA,EAAE7F,OAAS,GAAGH,KAAKmB,MAG7B4E,EAAkB/F,KAAKgG,MAG3BD,EAAkBnF,SAAQ,SAAA6B,OAClBwD,EAAa,EACjBxD,EAAK7B,SAAQ,SAAAsF,WACLC,EAAY,EAEhBD,EAAKtF,SAAQ,SAAAO,OACHe,EAAgBf,EAAOE,cAEzB+E,EAAyBlE,EAAcZ,MAAM+E,QAC7C,SAACC,EAAGC,UAAMD,EAAIC,EAAE/E,GAAK+E,EAAE9E,KACvB,GAEJ0E,IACKjE,EAAcN,EAAIwE,GAA0B1F,0BAIhDoF,EAAW1D,EAAMjC,OAAS,uBAA1BqG,EAA8BnI,qBAAS,GACpC8H,EACA,EAAIzF,EACJuF,EACAQ,EAAK1C,SAAS/F,EAAI0C,EACtB+F,EAAK1C,SAAS1F,OAEdyH,EAAW9F,KAAK,CACZmE,eACO+B,GACH,IAAIxC,EAAS,MACH,IACNC,SAAU8C,EAAKxC,eAAe,IAC9BL,SAAS,MAGjBvF,MAAO8H,IAEXF,EAAa,IAEbH,EAAWA,EAAW3F,OAAS,GAAK,CAChCgE,eACO2B,EAAWA,EAAW3F,OAAS,GAAGgE,KAClC+B,GACH,IAAIxC,EAAS,MACH,IACNC,SAAU8C,EAAKxC,eAAe,IAC9BL,SAAS,MAGjBvF,MACIyH,EAAWA,EAAW3F,OAAS,GAAG9B,MAAQ8H,GAElDF,GRxTM,GQwTqBvF,SAKhCoF,KAGXvF,OAAA,SAAOC,GACC1C,KAAKoG,YACAA,MAAM3D,OAAOC,MAI1BkG,SAAA,wBACwC,oBAAxBxC,4BAAO9B,MAAMjC,cC9TZwG,wBAoCbC,EACAC,EACA1C,EACAjF,QAEK4H,YAAcF,OACdG,QAAUC,SAASC,cAAcL,QACjCC,WAAaA,OACb3H,QAAUA,OACVgI,UAAY/C,OACZgD,WAAa,CACdC,UAAW,GACXC,OAAQ,SAEPX,UAAW,OACXzC,eAAiB,QACjBqD,YAAc,OAEdC,eAAiB,CAClBhF,SAAU,GACVc,YAAa,GACbF,MAAO,OACPhE,SAAU,IACVqG,UAAW,OACXgC,eAAe,EACfH,QAAQ,EACRI,MAAO,EACPC,WAAW,EACXC,cAAe,CACXC,OAAQ,GAEZvJ,MAAOP,KAAKiJ,QAAQc,wBAAwBxJ,MAC5C+G,WAAY,SAGX0C,kBAAoB,IACf,CACFxG,MAAO,CACH,CACIM,EAAG,OACHmG,EAAG,SACHrG,GAAI,QACJF,GAAI,EACJC,GAAI,EACJF,EACI,2DACJI,GAAI,GAER,CACIC,EAAG,OACHmG,EAAG,OACHrG,GAAI,OACJD,GAAI,EACJD,GAAI,EACJD,EACI,+HACJI,GAAI,IAGZC,EAAG,cAINoG,OAAShB,SAASiB,cAAc,eAChCD,OAAO3J,MAAQP,KAAKiJ,QAAQc,wBAAwBxJ,WACpD2J,OAAOhE,OAAS,SAChBzG,IAAMO,KAAKkK,OAAOE,WAAW,WAC7BnB,QAAQoB,YAAYrK,KAAKkK,aACzBI,WAAa,QACbC,UAAY,QAEZC,cAAgB,OAEhBC,kCAGDA,KAAA,2BACCC,uBAECC,EAAU,IAAIC,eACpBD,EAAQE,KAAK,MAAO7K,KAAK+I,YAAY,GACrC4B,EAAQG,mBAAqB,cACC,GAAtBH,EAAQI,YACc,KAAlBJ,EAAQK,OAAe,KACjBC,EAAWlE,KAAKC,MAAM2D,EAAQO,cACpCzK,EAAK0F,eAAiB8E,EAASxC,EAC/BhI,EAAK0K,eAAiBF,EAASG,EAC/B3K,EAAK4K,YACL5K,EAAKgC,WAIjBkI,EAAQW,KAAK,SAGjBC,OAAA,SAAOC,QACEC,QAAUD,KAOXd,iBAAA,2BACCtJ,QAAUpB,KAAKoB,SAAW,QAE1BA,aACEpB,KAAKyJ,eACLzJ,KAAKoB,SAGZsK,OAAOC,KAAK3L,KAAKgK,mBAAmBlH,SAAQ,SAAAhB,QACD8J,IAAnClG,EAAKS,eAAerE,KACpB4D,EAAKS,eAAerE,GAAa4D,EAAKsE,kBAClClI,UASRuJ,UAAA,sBACAQ,EAAM7L,KAAK8L,cAAc,MAAO,CAChCvL,MAAO,MACP2F,OAAQ,QAEZ2F,EAAIE,MAAMtF,SAAW,WACrBoF,EAAIE,MAAMC,OAAS,OACnBH,EAAIE,MAAME,QAAU,IACpBJ,EAAIE,MAAM1E,IAAM,IAEhB6B,SAASgD,KAAK7B,YAAYwB,OACtBM,EAAcnM,KAAK8L,cAAc,OAAQ,CACzCrI,EAAG,KAEPoI,EAAIxB,YAAY8B,QAEXC,WAAWpM,KAAKmG,gBAAgBrD,SAAQ,SAAAuJ,GACzC5E,EAAKtB,eAAekG,GAAM7I,MAAMV,SAAQ,SAAC1C,EAAMkM,GAC3CH,EAAYI,eAAe,KAAM,IAAKnM,EAAKqD,GAC3CgE,EAAKtB,eAAekG,GAAM7I,MACtB8I,GACF3I,GAAKwI,EAAYpC,wBAAwB7J,EAC3CuH,EAAKtB,eAAekG,GAAM7I,MACtB8I,GACFzI,GAAKsI,EAAYK,4BAItBpD,UAAUtG,SAAQ,SAAAgC,OACb2H,EAAa,IAAIzG,EAAW,CAC9BG,eAAgBsB,EAAKtB,eACrB/E,QAASqG,EAAKrG,QACd6E,SAAUnB,EACVrF,IAAKgI,EAAKhI,MAGdgN,EAAW3E,oBAEPhD,EAAKyE,OACL9B,EAAK4B,WAAWE,OAAOrH,KAAKuK,GAE5BhF,EAAK4B,WAAWC,UAAUpH,KAAKuK,SAKnChK,OAAA,SAAOC,uBAAAA,IAAAA,EAAU,OACjBgK,EAAe1M,KAAK2M,2BACpBD,IAAiB1M,KAAKkK,OAAOhE,cACxBgE,OAAOhE,OAASwG,QAEpBjN,IAAImN,UAAU,EAAG,EAAG5M,KAAKkK,OAAO3J,MAAOmM,QAEvCrD,WAAWC,UAAUxG,SAAQ,SAAAgC,GAC9BA,EAAKrC,OAAOC,MAGZ1C,KAAKqJ,WAAWE,OAAOlH,OAAS,EAAG,KAC7BwK,EAAY7M,KAAKqJ,WAAWE,OAAO,GACzCsD,EAAUpK,OAAOC,GACbmK,EAAUjE,iBACLtG,UAIbwK,OAAOC,uBAAsB,SAAAC,UAAQjF,EAAKtF,OAAOuK,SAO7C1K,QAAA,eACEC,EAAcvC,KAAKqJ,WAAWE,OAAO/G,QACvCD,GAAavC,KAAKqJ,WAAWC,UAAUpH,KAAKK,MAIpDoK,sBAAA,eACQzG,EAAS,kBACTlG,KAAKqJ,WAAWC,UAActJ,KAAKqJ,WAAWE,QAAQzG,SACtD,SAAAgC,GACQA,EAAKoB,QAAUpB,EAAKmB,SAAS9F,IAC7B+F,GAAUpB,EAAKoB,OAASpB,EAAKmB,SAAS9F,MAI3C+F,EAAS,MAGpB9C,UAAA,gBACIC,IAAAA,OACA4B,IAAAA,GACAwB,IAAAA,SAMML,EAAQ,UACPpG,KAAKqJ,WAAWC,UAChBtJ,KAAKqJ,WAAWE,QACrBrE,MAAK,SAAAJ,UAAQA,EAAKmB,SAAShB,KAAOA,KAEpC4B,QAAQC,IAAIzD,EAAQoD,GACpBL,MAAAA,GAAAA,EAAOhD,UAAU,CAAEC,OAAAA,EAAQoD,SAAAA,OAY/BqF,cAAA,SAAcmB,EAAWC,OACfC,EAAIjE,SAASkE,gBAAgB,6BAA8BH,OAC5D,IAAI7B,KAAK8B,EACVC,EAAEZ,eACE,KACAnB,EAAEiC,QAAQ,UAAU,SAASC,SAClB,IAAMA,EAAEC,iBAEnBL,EAAE9B,WAEH+B,KASXrM,YAAA,SAAYV,EAAcF,EAAOC,YAAPD,IAAAA,EAAI,YAAGC,IAAAA,EAAI,OAC7BqB,EAAUpB,EAAKqB,MAAM,WACzBD,EAAQ,GAAKtB,EAAI,EAAI,GACrBsB,EAAQ,GAAKrB,EAAI,GACVqB,EAAQE,KAAK,OAGxB0K,WAAA,SAAclM,UACCwL,OAAOC,KAAKzL,MAI3BsN,UAAA,SAAUtN,EAAWC,EAAW2D,EAAWmG,YAAAA,IAAAA,EAAI,SACtCxK,IAAIkB,YACJlB,IAAIgO,UAAY,6BAChBhO,IAAIiO,SAASxN,EAAGC,EAAG2D,EAAGmG,QACtBxK,IAAIkO,YACJlO,IAAIsB,gBAIb+L,SACMA,OAAQjE,KAAOA"}