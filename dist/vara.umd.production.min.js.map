{"version":3,"file":"vara.umd.production.min.js","sources":["../node_modules/svg-pathdata/src/mathUtils.ts","../node_modules/svg-pathdata/src/SVGPathDataTransformer.ts","../node_modules/svg-pathdata/src/TransformableSVG.ts","../node_modules/svg-pathdata/src/SVGPathDataParser.ts","../node_modules/svg-pathdata/src/SVGPathData.ts","../node_modules/svg-pathdata/src/SVGPathDataEncoder.ts","../src/index.ts"],"sourcesContent":["import { SVGPathData } from \"./SVGPathData\";\nimport { CommandA, CommandC } from \"./types\";\n\nexport function rotate([x, y]: [number, number], rad: number) {\n  return [\n    x * Math.cos(rad) - y * Math.sin(rad),\n    x * Math.sin(rad) + y * Math.cos(rad),\n  ];\n}\n\nconst DEBUG_CHECK_NUMBERS = true;\nexport function assertNumbers(...numbers: number[]) {\n  if (DEBUG_CHECK_NUMBERS) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i]) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not a number. ${typeof numbers[i]} == typeof ${numbers[i]}`);\n      }\n    }\n  }\n  return true;\n}\n\nconst PI = Math.PI;\n\n/**\n * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n * Fixes rX and rY.\n * Ensures lArcFlag and sweepFlag are 0 or 1\n * Adds center coordinates: command.cX, command.cY (relative or absolute, depending on command.relative)\n * Adds start and end arc parameters (in degrees): command.phi1, command.phi2; phi1 < phi2 iff. c.sweepFlag == true\n */\nexport function annotateArcCommand(c: CommandA, x1: number, y1: number) {\n  c.lArcFlag = (0 === c.lArcFlag) ? 0 : 1;\n  c.sweepFlag = (0 === c.sweepFlag) ? 0 : 1;\n  // tslint:disable-next-line\n  let {rX, rY, x, y} = c;\n\n  rX = Math.abs(c.rX);\n  rY = Math.abs(c.rY);\n  const [x1_, y1_] = rotate([(x1 - x) / 2, (y1 - y) / 2], -c.xRot / 180 * PI);\n  const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);\n\n  if (1 < testValue) {\n    rX *= Math.sqrt(testValue);\n    rY *= Math.sqrt(testValue);\n  }\n  c.rX = rX;\n  c.rY = rY;\n  const c_ScaleTemp = (Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2));\n  const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) *\n    Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));\n  const cx_ = rX * y1_ / rY * c_Scale;\n  const cy_ = -rY * x1_ / rX * c_Scale;\n  const cRot = rotate([cx_, cy_], c.xRot / 180 * PI);\n\n  c.cX = cRot[0] + (x1 + x) / 2;\n  c.cY = cRot[1] + (y1 + y) / 2;\n  c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);\n  c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);\n  if (0 === c.sweepFlag && c.phi2 > c.phi1) {\n    c.phi2 -= 2 * PI;\n  }\n  if (1 === c.sweepFlag && c.phi2 < c.phi1) {\n    c.phi2 += 2 * PI;\n  }\n  c.phi1 *= 180 / PI;\n  c.phi2 *= 180 / PI;\n}\n\n/**\n * Solves a quadratic system of equations of the form\n *      a * x + b * y = c\n *      x² + y² = 1\n * This can be understood as the intersection of the unit circle with a line.\n *      => y = (c - a x) / b\n *      => x² + (c - a x)² / b² = 1\n *      => x² b² + c² - 2 c a x + a² x² = b²\n *      => (a² + b²) x² - 2 a c x + (c² - b²) = 0\n */\nexport function intersectionUnitCircleLine(a: number, b: number, c: number): [number, number][] {\n  assertNumbers(a, b, c);\n  // cf. pqFormula\n  const termSqr = a * a + b * b - c * c;\n\n  if (0 > termSqr) {\n    return [];\n  } else if (0 === termSqr) {\n    return [\n      [\n        (a * c) / (a * a + b * b),\n        (b * c) / (a * a + b * b)]];\n  }\n  const term = Math.sqrt(termSqr);\n\n  return [\n    [\n      (a * c + b * term) / (a * a + b * b),\n      (b * c - a * term) / (a * a + b * b)],\n    [\n      (a * c - b * term) / (a * a + b * b),\n      (b * c + a * term) / (a * a + b * b)]];\n\n}\n\nexport const DEG = Math.PI / 180;\n\nexport function lerp(a: number, b: number, t: number) {\n  return (1 - t) * a + t * b;\n}\n\nexport function arcAt(c: number, x1: number, x2: number, phiDeg: number) {\n  return c + Math.cos(phiDeg / 180 * PI) * x1 + Math.sin(phiDeg / 180 * PI) * x2;\n}\n\nexport function bezierRoot(x0: number, x1: number, x2: number, x3: number) {\n  const EPS = 1e-6;\n  const x01 = x1 - x0;\n  const x12 = x2 - x1;\n  const x23 = x3 - x2;\n  const a = 3 * x01 + 3 * x23 - 6 * x12;\n  const b = (x12 - x01) * 6;\n  const c = 3 * x01;\n  // solve a * t² + b * t + c = 0\n\n  if (Math.abs(a) < EPS) {\n    // equivalent to b * t + c =>\n    return [-c / b];\n  }\n  return pqFormula(b / a, c / a, EPS);\n\n}\n\nexport function bezierAt(x0: number, x1: number, x2: number, x3: number, t: number) {\n  // console.log(x0, y0, x1, y1, x2, y2, x3, y3, t)\n  const s = 1 - t;\n  const c0 = s * s * s;\n  const c1 = 3 * s * s * t;\n  const c2 = 3 * s * t * t;\n  const c3 = t * t * t;\n\n  return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;\n}\n\nfunction pqFormula(p: number, q: number, PRECISION = 1e-6) {\n  // 4 times the discriminant:in\n  const discriminantX4 = p * p / 4 - q;\n\n  if (discriminantX4 < -PRECISION) {\n    return [];\n  } else if (discriminantX4 <= PRECISION) {\n    return [-p / 2];\n  }\n  const root = Math.sqrt(discriminantX4);\n\n  return [-(p / 2) - root, -(p / 2) + root];\n\n}\n\nexport function a2c(arc: CommandA, x0: number, y0: number): CommandC[] {\n  if (!arc.cX) {\n    annotateArcCommand(arc, x0, y0);\n  }\n\n  const phiMin = Math.min(arc.phi1!, arc.phi2!), phiMax = Math.max(arc.phi1!, arc.phi2!), deltaPhi = phiMax - phiMin;\n  const partCount = Math.ceil(deltaPhi / 90 );\n\n  const result: CommandC[] = new Array(partCount);\n  let prevX = x0, prevY = y0;\n  for (let i = 0; i < partCount; i++) {\n    const phiStart = lerp(arc.phi1!, arc.phi2!, i / partCount);\n    const phiEnd = lerp(arc.phi1!, arc.phi2!, (i + 1) / partCount);\n    const deltaPhi = phiEnd - phiStart;\n    const f = 4 / 3 * Math.tan(deltaPhi * DEG / 4);\n    // x1/y1, x2/y2 and x/y coordinates on the unit circle for phiStart/phiEnd\n    const [x1, y1] = [\n      Math.cos(phiStart * DEG) - f * Math.sin(phiStart * DEG),\n      Math.sin(phiStart * DEG) + f * Math.cos(phiStart * DEG)];\n    const [x, y] = [Math.cos(phiEnd * DEG), Math.sin(phiEnd * DEG)];\n    const [x2, y2] = [x + f * Math.sin(phiEnd * DEG), y - f * Math.cos(phiEnd * DEG)];\n    result[i] = {relative: arc.relative, type: SVGPathData.CURVE_TO } as any;\n    const transform = (x: number, y: number) => {\n      const [xTemp, yTemp] = rotate([x * arc.rX, y * arc.rY], arc.xRot);\n      return [arc.cX! + xTemp, arc.cY! + yTemp];\n    };\n    [result[i].x1, result[i].y1] = transform(x1, y1);\n    [result[i].x2, result[i].y2] = transform(x2, y2);\n    [result[i].x, result[i].y] = transform(x, y);\n    if (arc.relative) {\n      result[i].x1 -= prevX;\n      result[i].y1 -= prevY;\n      result[i].x2 -= prevX;\n      result[i].y2 -= prevY;\n      result[i].x -= prevX;\n      result[i].y -= prevY;\n    }\n    [prevX, prevY] = [result[i].x, result[i].y];\n  }\n  return result;\n}\n","// Transform SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\nimport { a2c, annotateArcCommand, arcAt, assertNumbers, bezierAt, bezierRoot,\n  intersectionUnitCircleLine } from \"./mathUtils\";\nimport { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n\nexport namespace SVGPathDataTransformer {\n  // Predefined transforming functions\n  // Rounds commands values\n  export function ROUND(roundVal = 1e13) {\n    assertNumbers(roundVal);\n    function rf(val: number) { return Math.round(val * roundVal) / roundVal; }\n    return function round(command: any) {\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = rf(command.x1);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = rf(command.y1);\n      }\n\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = rf(command.x2);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = rf(command.y2);\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = rf(command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = rf(command.y);\n      }\n\n      if (\"undefined\" !== typeof command.rX) {\n        command.rX = rf(command.rX);\n      }\n      if (\"undefined\" !== typeof command.rY) {\n        command.rY = rf(command.rY);\n      }\n\n      return command;\n    };\n  }\n  // Relative to absolute commands\n  export function TO_ABS() {\n    return INFO((command, prevX, prevY) => {\n      if (command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 += prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 += prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x += prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y += prevY;\n        }\n        command.relative = false;\n      }\n      return command;\n    });\n  }\n  // Absolute to relative commands\n  export function TO_REL() {\n    return INFO((command, prevX, prevY) => {\n      if (!command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 -= prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 -= prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y -= prevY;\n        }\n        command.relative = true;\n      }\n      return command;\n    });\n  }\n  // Convert H, V, Z and A with rX = 0 to L\n  export function NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true) {\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n      if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n      if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? pathStartX - prevX : pathStartX;\n        command.y = command.relative ? pathStartY - prevY : pathStartY;\n      }\n      if (command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY)) {\n        command.type = SVGPathData.LINE_TO;\n        delete command.rX;\n        delete command.rY;\n        delete command.xRot;\n        delete command.lArcFlag;\n        delete command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  /*\n   * Transforms smooth curves and quads to normal curves and quads (SsTt to CcQq)\n   */\n  export function NORMALIZE_ST() {\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        command.type = SVGPathData.CURVE_TO;\n        prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;\n        prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;\n        command.x1 = command.relative ? prevX - prevCurveC2X : 2 * prevX - prevCurveC2X;\n        command.y1 = command.relative ? prevY - prevCurveC2Y : 2 * prevY - prevCurveC2Y;\n      }\n      if (command.type & SVGPathData.CURVE_TO) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;\n        command.x1 = command.relative ? prevX - prevQuadCX : 2 * prevX - prevQuadCX;\n        command.y1 = command.relative ? prevY - prevQuadCY : 2 * prevY - prevQuadCY;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y1;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      return command;\n    });\n  }\n  /*\n   * A quadratic bézier curve can be represented by a cubic bézier curve which has\n   * the same end points as the quadratic and both control points in place of the\n   * quadratic\"s one.\n   *\n   * This transformer replaces QqTt commands with Cc commands respectively.\n   * This is useful for reading path data into a system which only has a\n   * representation for cubic curves.\n   */\n  export function QT_TO_C() {\n    let prevQuadX1 = NaN;\n    let prevQuadY1 = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;\n        prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;\n        command.x1 = command.relative ? prevX - prevQuadX1 : 2 * prevX - prevQuadX1;\n        command.y1 = command.relative ? prevY - prevQuadY1 : 2 * prevY - prevQuadY1;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;\n        const x1 = command.x1;\n        const y1 = command.y1;\n\n        command.type = SVGPathData.CURVE_TO;\n        command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;\n        command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;\n        command.x2 = (command.x + x1 * 2) / 3;\n        command.y2 = (command.y + y1 * 2) / 3;\n      } else {\n        prevQuadX1 = NaN;\n        prevQuadY1 = NaN;\n      }\n\n      return command;\n    });\n  }\n  export function INFO(\n    f: (command: any, prevXAbs: number, prevYAbs: number,\n        pathStartXAbs: number, pathStartYAbs: number) => any | any[]) {\n    let prevXAbs = 0;\n    let prevYAbs = 0;\n    let pathStartXAbs = NaN;\n    let pathStartYAbs = NaN;\n\n    return function transform(command: any) {\n      if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n\n      const result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        prevXAbs = pathStartXAbs;\n        prevYAbs = pathStartYAbs;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        prevXAbs = (command.relative ? prevXAbs + command.x : command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        prevYAbs = (command.relative ? prevYAbs + command.y : command.y);\n      }\n\n      if (command.type & SVGPathData.MOVE_TO) {\n        pathStartXAbs = prevXAbs;\n        pathStartYAbs = prevYAbs;\n      }\n\n      return result;\n    };\n  }\n  /*\n   * remove 0-length segments\n   */\n  export function SANITIZE(EPS = 0) {\n    assertNumbers(EPS);\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      const abs = Math.abs;\n      let skip = false;\n      let x1Rel = 0;\n      let y1Rel = 0;\n\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;\n        y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;\n      }\n      if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;\n      } else if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y2;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      if (command.type & SVGPathData.LINE_COMMANDS ||\n        command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY || !command.lArcFlag) ||\n        command.type & SVGPathData.CURVE_TO || command.type & SVGPathData.SMOOTH_CURVE_TO ||\n        command.type & SVGPathData.QUAD_TO || command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        const xRel = \"undefined\" === typeof command.x ? 0 :\n          (command.relative ? command.x : command.x - prevX);\n        const yRel = \"undefined\" === typeof command.y ? 0 :\n          (command.relative ? command.y : command.y - prevY);\n\n        x1Rel = !isNaN(prevQuadCX) ? prevQuadCX - prevX :\n          \"undefined\" === typeof command.x1 ? x1Rel :\n            command.relative ? command.x :\n              command.x1 - prevX;\n        y1Rel = !isNaN(prevQuadCY) ? prevQuadCY - prevY :\n          \"undefined\" === typeof command.y1 ? y1Rel :\n            command.relative ? command.y :\n              command.y1 - prevY;\n\n        const x2Rel = \"undefined\" === typeof command.x2 ? 0 :\n          (command.relative ? command.x : command.x2 - prevX);\n        const y2Rel = \"undefined\" === typeof command.y2 ? 0 :\n          (command.relative ? command.y : command.y2 - prevY);\n\n        if (abs(xRel) <= EPS && abs(yRel) <= EPS &&\n          abs(x1Rel) <= EPS && abs(y1Rel) <= EPS &&\n          abs(x2Rel) <= EPS && abs(y2Rel) <= EPS) {\n          skip = true;\n        }\n      }\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) {\n          skip = true;\n        }\n      }\n\n      return skip ? [] : command;\n    });\n  }\n  // SVG Transforms : http://www.w3.org/TR/SVGTiny12/coords.html#TransformList\n  // Matrix : http://apike.ca/prog_svg_transform.html\n  // a c e\n  // b d f\n  export function MATRIX(a: number, b: number, c: number, d: number, e: number, f: number) {\n    assertNumbers(a, b, c, d, e, f);\n\n    return INFO((command, prevX, prevY, pathStartX) => {\n      const origX1 = command.x1;\n      const origX2 = command.x2;\n      // if isNaN(pathStartX), then this is the first command, which is ALWAYS an\n      // absolute MOVE_TO, regardless what the relative flag says\n      const comRel = command.relative && !isNaN(pathStartX);\n      const x = \"undefined\" !== typeof command.x ? command.x : (comRel ? 0 : prevX);\n      const y = \"undefined\" !== typeof command.y ? command.y : (comRel ? 0 : prevY);\n\n      if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = (command.x * a) + (y * c) + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = (x * b) + command.y * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = origX1 * b + command.y1 * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = origX2 * b + command.y2 * d + (comRel ? 0 : f);\n      }\n      function sqr(x: number) { return x * x; }\n      const det = a * d - b * c;\n\n      if (\"undefined\" !== typeof command.xRot) {\n        // Skip if this is a pure translation\n        if (1 !== a || 0 !== b || 0 !== c || 1 !== d) {\n          // Special case for singular matrix\n          if (0 === det) {\n            // In the singular case, the arc is compressed to a line. The actual geometric image of the original\n            // curve under this transform possibly extends beyond the starting and/or ending points of the segment, but\n            // for simplicity we ignore this detail and just replace this command with a single line segment.\n            delete command.rX;\n            delete command.rY;\n            delete command.xRot;\n            delete command.lArcFlag;\n            delete command.sweepFlag;\n            command.type = SVGPathData.LINE_TO;\n          } else {\n            // Convert to radians\n            const xRot = command.xRot * Math.PI / 180;\n\n            // Convert rotated ellipse to general conic form\n            // x0^2/rX^2 + y0^2/rY^2 - 1 = 0\n            // x0 = x*cos(xRot) + y*sin(xRot)\n            // y0 = -x*sin(xRot) + y*cos(xRot)\n            // --> A*x^2 + B*x*y + C*y^2 - 1 = 0, where\n            const sinRot = Math.sin(xRot);\n            const cosRot = Math.cos(xRot);\n            const xCurve = 1 / sqr(command.rX);\n            const yCurve = 1 / sqr(command.rY);\n            const A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;\n            const B = 2 * sinRot * cosRot * (xCurve - yCurve);\n            const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;\n\n            // Apply matrix to A*x^2 + B*x*y + C*y^2 - 1 = 0\n            // x1 = a*x + c*y\n            // y1 = b*x + d*y\n            //      (we can ignore e and f, since pure translations don\"t affect the shape of the ellipse)\n            // --> A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 = 0, where\n            const A1 = A * d * d - B * b * d + C * b * b;\n            const B1 = B * (a * d + b * c) - 2 * (A * c * d + C * a * b);\n            const C1 = A * c * c - B * a * c + C * a * a;\n\n            // Unapply newXRot to get back to axis-aligned ellipse equation\n            // x1 = x2*cos(newXRot) - y2*sin(newXRot)\n            // y1 = x2*sin(newXRot) + y2*cos(newXRot)\n            // A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 =\n            //   x2^2*(A1*cos(newXRot)^2 + B1*sin(newXRot)*cos(newXRot) + C1*sin(newXRot)^2)\n            //   + x2*y2*(2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2))\n            //   + y2^2*(A1*sin(newXRot)^2 - B1*sin(newXRot)*cos(newXRot) + C1*cos(newXRot)^2)\n            //   (which must have the same zeroes as)\n            // x2^2/newRX^2 + y2^2/newRY^2 - 1\n            //   (so we have)\n            // 2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2) = 0\n            // (A1 - C1)*sin(2*newXRot) = B1*cos(2*newXRot)\n            // 2*newXRot = atan2(B1, A1 - C1)\n            const newXRot = ((Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI) / 2;\n            // For any integer n, (atan2(B1, A1 - C1) + n*pi)/2 is a solution to the above; incrementing n just swaps\n            // the x and y radii computed below (since that\"s what rotating an ellipse by pi/2 does).  Choosing the\n            // rotation between 0 and pi/2 eliminates the ambiguity and leads to more predictable output.\n\n            // Finally, we get newRX and newRY from the same-zeroes relationship that gave us newXRot\n            const newSinRot = Math.sin(newXRot);\n            const newCosRot = Math.cos(newXRot);\n\n            command.rX = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newCosRot) + B1 * newSinRot * newCosRot + C1 * sqr(newSinRot));\n            command.rY = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newSinRot) - B1 * newSinRot * newCosRot + C1 * sqr(newCosRot));\n            command.xRot = newXRot * 180 / Math.PI;\n          }\n        }\n      }\n      // sweepFlag needs to be inverted when mirroring shapes\n      // see http://www.itk.ilstu.edu/faculty/javila/SVG/SVG_drawing1/elliptical_curve.htm\n      // m 65,10 a 50,25 0 1 0 50,25\n      // M 65,60 A 50,25 0 1 1 115,35\n      if (\"undefined\" !== typeof command.sweepFlag && 0 > det) {\n        command.sweepFlag = +!command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  export function ROTATE(a: number, x = 0, y = 0) {\n    assertNumbers(a, x, y);\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    return MATRIX(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);\n  }\n  export function TRANSLATE(dX: number, dY = 0) {\n    assertNumbers(dX, dY);\n    return MATRIX(1, 0, 0, 1, dX, dY);\n  }\n  export function SCALE(dX: number, dY = dX) {\n    assertNumbers(dX, dY);\n    return MATRIX(dX, 0, 0, dY, 0, 0);\n  }\n  export function SKEW_X(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, 0, Math.atan(a), 1, 0, 0);\n  }\n  export function SKEW_Y(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, Math.atan(a), 0, 1, 0, 0);\n  }\n  export function X_AXIS_SYMMETRY(xOffset = 0) {\n    assertNumbers(xOffset);\n    return MATRIX(-1, 0, 0, 1, xOffset, 0);\n  }\n  export function Y_AXIS_SYMMETRY(yOffset = 0) {\n    assertNumbers(yOffset);\n    return MATRIX(1, 0, 0, -1, 0, yOffset);\n  }\n  // Convert arc commands to curve commands\n  export function A_TO_C() {\n    return INFO((command, prevX, prevY) => {\n      if (SVGPathData.ARC === command.type) {\n        return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);\n      }\n      return command;\n    });\n  }\n  // @see annotateArcCommand\n  export function ANNOTATE_ARCS() {\n    return INFO((c, x1, y1) => {\n      if (c.relative) {\n        x1 = 0;\n        y1 = 0;\n      }\n      if (SVGPathData.ARC === c.type) {\n        annotateArcCommand(c, x1, y1);\n      }\n      return c;\n    });\n  }\n  export function CLONE() {\n    return (c: SVGCommand) => {\n      const result = {} as SVGCommand;\n      // tslint:disable-next-line\n      for (const key in c) {\n        result[key as keyof SVGCommand] = c[key as keyof SVGCommand];\n      }\n      return result;\n    };\n  }\n  // @see annotateArcCommand\n  export function CALCULATE_BOUNDS() {\n    const clone = CLONE();\n    const toAbs = TO_ABS();\n    const qtToC = QT_TO_C();\n    const normST = NORMALIZE_ST();\n    const f: TransformFunction & {minX: number, maxX: number, minY: number, maxY: number} =\n        INFO((command, prevXAbs, prevYAbs) => {\n      const c = normST(qtToC(toAbs(clone(command))));\n      function fixX(absX: number) {\n        if (absX > f.maxX) { f.maxX = absX; }\n        if (absX < f.minX) { f.minX = absX; }\n      }\n      function fixY(absY: number) {\n        if (absY > f.maxY) { f.maxY = absY; }\n        if (absY < f.minY) { f.minY = absY; }\n      }\n      if (c.type & SVGPathData.DRAWING_COMMANDS) {\n        fixX(prevXAbs);\n        fixY(prevYAbs);\n      }\n      if (c.type & SVGPathData.HORIZ_LINE_TO) {\n        fixX(c.x);\n      }\n      if (c.type & SVGPathData.VERT_LINE_TO) {\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.LINE_TO) {\n        fixX(c.x);\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.CURVE_TO) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);\n\n        for (const derivRoot of xDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));\n          }\n        }\n        const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);\n\n        for (const derivRoot of yDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));\n          }\n        }\n      }\n      if (c.type & SVGPathData.ARC) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        annotateArcCommand(c, prevXAbs, prevYAbs);\n        // p = cos(phi) * xv + sin(phi) * yv\n        // dp = -sin(phi) * xv + cos(phi) * yv = 0\n        const xRotRad = c.xRot / 180 * Math.PI;\n        // points on ellipse for phi = 0° and phi = 90°\n        const x0 = Math.cos(xRotRad) * c.rX;\n        const y0 = Math.sin(xRotRad) * c.rX;\n        const x90 = -Math.sin(xRotRad) * c.rY;\n        const y90 = Math.cos(xRotRad) * c.rY;\n\n        // annotateArcCommand returns phi1 and phi2 such that -180° < phi1 < 180° and phi2 is smaller or greater\n        // depending on the sweep flag. Calculate phiMin, phiMax such that -180° < phiMin < 180° and phiMin < phiMax\n        const [phiMin, phiMax] = c.phi1 < c.phi2 ?\n          [c.phi1, c.phi2] :\n          (-180 > c.phi2 ? [c.phi2 + 360, c.phi1 + 360] : [c.phi2, c.phi1]);\n        const normalizeXiEta = ([xi, eta]: [number, number]) => {\n          const phiRad = Math.atan2(eta, xi);\n          const phi = phiRad * 180 / Math.PI;\n\n          return phi < phiMin ? phi + 360 : phi;\n        };\n        // xi = cos(phi), eta = sin(phi)\n\n        const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);\n        for (const derivRoot of xDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixX(arcAt(c.cX, x0, x90, derivRoot));\n          }\n        }\n\n        const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);\n        for (const derivRoot of yDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixY(arcAt(c.cY, y0, y90, derivRoot));\n          }\n        }\n      }\n      return command;\n    }) as any;\n\n    f.minX = Infinity;\n    f.maxX = -Infinity;\n    f.minY = Infinity;\n    f.maxY = -Infinity;\n    return f;\n  }\n}\n","import { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformFunction } from \"./types\";\n\nexport abstract class TransformableSVG {\n  round(x?: number) {\n    return this.transform(SVGPathDataTransformer.ROUND(x));\n  }\n\n  toAbs() {\n    return this.transform(SVGPathDataTransformer.TO_ABS());\n  }\n\n  toRel() {\n    return this.transform(SVGPathDataTransformer.TO_REL());\n  }\n\n  normalizeHVZ(a?: boolean, b?: boolean, c?: boolean) {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a, b, c));\n  }\n\n  normalizeST() {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_ST());\n  }\n\n  qtToC() {\n    return this.transform(SVGPathDataTransformer.QT_TO_C());\n  }\n\n  aToC() {\n    return this.transform(SVGPathDataTransformer.A_TO_C());\n  }\n\n  sanitize(eps?: number) {\n    return this.transform(SVGPathDataTransformer.SANITIZE(eps));\n  }\n\n  translate(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.TRANSLATE(x, y));\n  }\n\n  scale(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.SCALE(x, y));\n  }\n\n  rotate(a: number, x?: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.ROTATE(a, x, y));\n  }\n\n  matrix(a: number, b: number, c: number, d: number, e: number, f: number) {\n    return this.transform(SVGPathDataTransformer.MATRIX(a, b, c, d, e, f));\n  }\n\n  skewX(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_X(a));\n  }\n\n  skewY(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_Y(a));\n  }\n\n  xSymmetry(xOffset?: number) {\n    return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));\n  }\n\n  ySymmetry(yOffset?: number) {\n    return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));\n  }\n\n  annotateArcs() {\n    return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());\n  }\n\n  abstract transform(transformFunction: TransformFunction): this;\n}\n","// Parse SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\nimport { COMMAND_ARG_COUNTS, SVGPathData } from \"./SVGPathData\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n// Private consts : Char groups\nconst isWhiteSpace = (c: string) =>\n  \" \" === c || \"\\t\" === c || \"\\r\" === c || \"\\n\" === c;\nconst isDigit = (c: string) =>\n  \"0\".charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= \"9\".charCodeAt(0);\nconst COMMANDS = \"mMzZlLhHvVcCsSqQtTaA\";\n\nexport class SVGPathDataParser extends TransformableSVG {\n  private curNumber: string = \"\";\n  private curCommandType: SVGCommand[\"type\"] | -1 = -1;\n  private curCommandRelative = false;\n  private canParseCommandOrComma = true;\n  private curNumberHasExp = false;\n  private curNumberHasExpDigits = false;\n  private curNumberHasDecimal = false;\n  private curArgs: number[] = [];\n\n  constructor() {\n    super();\n  }\n\n  finish(commands: SVGCommand[] = []) {\n    this.parse(\" \", commands);\n    // Adding residual command\n    if (0 !== this.curArgs.length || !this.canParseCommandOrComma) {\n      throw new SyntaxError(\"Unterminated command at the path end.\");\n    }\n    return commands;\n  }\n\n  parse(str: string, commands: SVGCommand[] = []) {\n    const finishCommand = (command: SVGCommand) => {\n      commands.push(command);\n      this.curArgs.length = 0;\n      this.canParseCommandOrComma = true;\n    };\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      // White spaces parsing\n      const isAArcFlag = this.curCommandType === SVGPathData.ARC &&\n        (this.curArgs.length === 3 || this.curArgs.length === 4) &&\n        this.curNumber.length === 1 &&\n        (this.curNumber === \"0\" || this.curNumber === \"1\");\n      const isEndingDigit = isDigit(c) && (\n        (this.curNumber === \"0\" && c === \"0\") ||\n        isAArcFlag\n      );\n\n      if (\n        isDigit(c) &&\n        !isEndingDigit\n      ) {\n        this.curNumber += c;\n        this.curNumberHasExpDigits = this.curNumberHasExp;\n        continue;\n      }\n      if (\"e\" === c || \"E\" === c) {\n        this.curNumber += c;\n        this.curNumberHasExp = true;\n        continue;\n      }\n      if (\n        (\"-\" === c || \"+\" === c) &&\n        this.curNumberHasExp &&\n        !this.curNumberHasExpDigits\n      ) {\n        this.curNumber += c;\n        continue;\n      }\n      // if we already have a \".\", it means we are starting a new number\n      if (\".\" === c && !this.curNumberHasExp && !this.curNumberHasDecimal && !isAArcFlag) {\n        this.curNumber += c;\n        this.curNumberHasDecimal = true;\n        continue;\n      }\n\n      // New number\n      if (this.curNumber && -1 !== this.curCommandType) {\n        const val = Number(this.curNumber);\n        if (isNaN(val)) {\n          throw new SyntaxError(`Invalid number ending at ${i}`);\n        }\n        if (this.curCommandType === SVGPathData.ARC) {\n          if (0 === this.curArgs.length || 1 === this.curArgs.length) {\n            if (0 > val) {\n              throw new SyntaxError(\n                `Expected positive number, got \"${val}\" at index \"${i}\"`,\n              );\n            }\n          } else if (3 === this.curArgs.length || 4 === this.curArgs.length) {\n            if (\"0\" !== this.curNumber && \"1\" !== this.curNumber) {\n              throw new SyntaxError(\n                `Expected a flag, got \"${this.curNumber}\" at index \"${i}\"`,\n              );\n            }\n          }\n        }\n        this.curArgs.push(val);\n        if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {\n          if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.HORIZ_LINE_TO,\n              relative: this.curCommandRelative,\n              x: val,\n            });\n          } else if (SVGPathData.VERT_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.VERT_LINE_TO,\n              relative: this.curCommandRelative,\n              y: val,\n            });\n            // Move to / line to / smooth quadratic curve to commands (x, y)\n          } else if (\n            this.curCommandType === SVGPathData.MOVE_TO ||\n            this.curCommandType === SVGPathData.LINE_TO ||\n            this.curCommandType === SVGPathData.SMOOTH_QUAD_TO\n          ) {\n            finishCommand({\n              type: this.curCommandType,\n              relative: this.curCommandRelative,\n              x: this.curArgs[0],\n              y: this.curArgs[1],\n            } as SVGCommand);\n            // Switch to line to state\n            if (SVGPathData.MOVE_TO === this.curCommandType) {\n              this.curCommandType = SVGPathData.LINE_TO;\n            }\n          } else if (this.curCommandType === SVGPathData.CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.CURVE_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x2: this.curArgs[2],\n              y2: this.curArgs[3],\n              x: this.curArgs[4],\n              y: this.curArgs[5],\n            });\n          } else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.SMOOTH_CURVE_TO,\n              relative: this.curCommandRelative,\n              x2: this.curArgs[0],\n              y2: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.QUAD_TO) {\n            finishCommand({\n              type: SVGPathData.QUAD_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.ARC) {\n            finishCommand({\n              type: SVGPathData.ARC,\n              relative: this.curCommandRelative,\n              rX: this.curArgs[0],\n              rY: this.curArgs[1],\n              xRot: this.curArgs[2],\n              lArcFlag: this.curArgs[3] as 0 | 1,\n              sweepFlag: this.curArgs[4] as 0 | 1,\n              x: this.curArgs[5],\n              y: this.curArgs[6],\n            });\n          }\n        }\n        this.curNumber = \"\";\n        this.curNumberHasExpDigits = false;\n        this.curNumberHasExp = false;\n        this.curNumberHasDecimal = false;\n        this.canParseCommandOrComma = true;\n      }\n      // Continue if a white space or a comma was detected\n      if (isWhiteSpace(c)) {\n        continue;\n      }\n      if (\",\" === c && this.canParseCommandOrComma) {\n        // L 0,0, H is not valid:\n        this.canParseCommandOrComma = false;\n        continue;\n      }\n      // if a sign is detected, then parse the new number\n      if (\"+\" === c || \"-\" === c || \".\" === c) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = \".\" === c;\n        continue;\n      }\n      // if a 0 is detected, then parse the new number\n      if (isEndingDigit) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = false;\n        continue;\n      }\n\n      // Adding residual command\n      if (0 !== this.curArgs.length) {\n        throw new SyntaxError(`Unterminated command at index ${i}.`);\n      }\n      if (!this.canParseCommandOrComma) {\n        throw new SyntaxError(\n          `Unexpected character \"${c}\" at index ${i}. Command cannot follow comma`,\n        );\n      }\n      this.canParseCommandOrComma = false;\n      // Detecting the next command\n      if (\"z\" === c || \"Z\" === c) {\n        commands.push({\n          type: SVGPathData.CLOSE_PATH,\n        });\n        this.canParseCommandOrComma = true;\n        this.curCommandType = -1;\n        continue;\n        // Horizontal move to command\n      } else if (\"h\" === c || \"H\" === c) {\n        this.curCommandType = SVGPathData.HORIZ_LINE_TO;\n        this.curCommandRelative = \"h\" === c;\n        // Vertical move to command\n      } else if (\"v\" === c || \"V\" === c) {\n        this.curCommandType = SVGPathData.VERT_LINE_TO;\n        this.curCommandRelative = \"v\" === c;\n        // Move to command\n      } else if (\"m\" === c || \"M\" === c) {\n        this.curCommandType = SVGPathData.MOVE_TO;\n        this.curCommandRelative = \"m\" === c;\n        // Line to command\n      } else if (\"l\" === c || \"L\" === c) {\n        this.curCommandType = SVGPathData.LINE_TO;\n        this.curCommandRelative = \"l\" === c;\n        // Curve to command\n      } else if (\"c\" === c || \"C\" === c) {\n        this.curCommandType = SVGPathData.CURVE_TO;\n        this.curCommandRelative = \"c\" === c;\n        // Smooth curve to command\n      } else if (\"s\" === c || \"S\" === c) {\n        this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;\n        this.curCommandRelative = \"s\" === c;\n        // Quadratic bezier curve to command\n      } else if (\"q\" === c || \"Q\" === c) {\n        this.curCommandType = SVGPathData.QUAD_TO;\n        this.curCommandRelative = \"q\" === c;\n        // Smooth quadratic bezier curve to command\n      } else if (\"t\" === c || \"T\" === c) {\n        this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;\n        this.curCommandRelative = \"t\" === c;\n        // Elliptic arc command\n      } else if (\"a\" === c || \"A\" === c) {\n        this.curCommandType = SVGPathData.ARC;\n        this.curCommandRelative = \"a\" === c;\n      } else {\n        throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}.`);\n      }\n    }\n    return commands;\n  }\n  /**\n   * Return a wrapper around this parser which applies the transformation on parsed commands.\n   */\n  transform(transform: TransformFunction) {\n    const result = Object.create(this, {\n      parse: {\n        value(chunk: string, commands: SVGCommand[] = []) {\n          const parsedCommands = Object.getPrototypeOf(this).parse.call(\n            this,\n            chunk,\n          );\n          for (const c of parsedCommands) {\n            const cT = transform(c);\n            if (Array.isArray(cT)) {\n              commands.push(...cT);\n            } else {\n              commands.push(cT);\n            }\n          }\n          return commands;\n        },\n      },\n    });\n    return result as this;\n  }\n}\n","import { encodeSVGPath } from \"./SVGPathDataEncoder\";\nimport { SVGPathDataParser } from \"./SVGPathDataParser\";\nimport { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand } from \"./types\";\n\nexport class SVGPathData extends TransformableSVG {\n  commands: SVGCommand[];\n  constructor(content: string | SVGCommand[]) {\n    super();\n    if (\"string\" === typeof content) {\n      this.commands = SVGPathData.parse(content);\n    } else {\n      this.commands = content;\n    }\n  }\n\n  encode() {\n    return SVGPathData.encode(this.commands);\n  }\n\n  getBounds() {\n    const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();\n\n    this.transform(boundsTransform);\n    return boundsTransform;\n  }\n\n  transform(\n    transformFunction: (input: SVGCommand) => SVGCommand | SVGCommand[],\n  ) {\n    const newCommands = [];\n\n    for (const command of this.commands) {\n      const transformedCommand = transformFunction(command);\n\n      if (Array.isArray(transformedCommand)) {\n        newCommands.push(...transformedCommand);\n      } else {\n        newCommands.push(transformedCommand);\n      }\n    }\n    this.commands = newCommands;\n    return this;\n  }\n\n  static encode(commands: SVGCommand[]) {\n    return encodeSVGPath(commands);\n      }\n\n  static parse(path: string) {\n    const parser = new SVGPathDataParser();\n    const commands: SVGCommand[] = [];\n    parser.parse(path, commands);\n    parser.finish(commands);\n    return commands;\n  }\n\n  static readonly CLOSE_PATH: 1 = 1;\n  static readonly MOVE_TO: 2 = 2;\n  static readonly HORIZ_LINE_TO: 4 = 4;\n  static readonly VERT_LINE_TO: 8 = 8;\n  static readonly LINE_TO: 16 = 16;\n  static readonly CURVE_TO: 32 = 32;\n  static readonly SMOOTH_CURVE_TO: 64 = 64;\n  static readonly QUAD_TO: 128 = 128;\n  static readonly SMOOTH_QUAD_TO: 256 = 256;\n  static readonly ARC: 512 = 512;\n  static readonly LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;\n  static readonly DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO | SVGPathData.LINE_TO |\n  SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO | SVGPathData.QUAD_TO |\n  SVGPathData.SMOOTH_QUAD_TO | SVGPathData.ARC;\n}\n\nexport const COMMAND_ARG_COUNTS = {\n    [SVGPathData.MOVE_TO]: 2,\n    [SVGPathData.LINE_TO]: 2,\n    [SVGPathData.HORIZ_LINE_TO]: 1,\n    [SVGPathData.VERT_LINE_TO]: 1,\n    [SVGPathData.CLOSE_PATH]: 0,\n    [SVGPathData.QUAD_TO]: 4,\n    [SVGPathData.SMOOTH_QUAD_TO]: 2,\n    [SVGPathData.CURVE_TO]: 6,\n    [SVGPathData.SMOOTH_CURVE_TO]: 4,\n    [SVGPathData.ARC]: 7,\n};\n\nexport {encodeSVGPath} from \"./SVGPathDataEncoder\";\nexport {SVGPathDataParser} from \"./SVGPathDataParser\";\nexport {SVGPathDataTransformer} from \"./SVGPathDataTransformer\";\n","import { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand } from \"./types\";\n\n// Encode SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\n// Private consts : Char groups\nconst WSP = \" \";\n\nexport function encodeSVGPath(commands: SVGCommand | SVGCommand[]) {\n  let str = \"\";\n\n  if (!Array.isArray(commands)) {\n    commands = [commands];\n  }\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    if (command.type === SVGPathData.CLOSE_PATH) {\n      str += \"z\";\n    } else if (command.type === SVGPathData.HORIZ_LINE_TO) {\n      str += (command.relative ? \"h\" : \"H\") +\n        command.x;\n    } else if (command.type === SVGPathData.VERT_LINE_TO) {\n      str += (command.relative ? \"v\" : \"V\") +\n        command.y;\n    } else if (command.type === SVGPathData.MOVE_TO) {\n      str += (command.relative ? \"m\" : \"M\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.LINE_TO) {\n      str += (command.relative ? \"l\" : \"L\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.CURVE_TO) {\n      str += (command.relative ? \"c\" : \"C\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_CURVE_TO) {\n      str += (command.relative ? \"s\" : \"S\") +\n        command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.QUAD_TO) {\n      str += (command.relative ? \"q\" : \"Q\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_QUAD_TO) {\n      str += (command.relative ? \"t\" : \"T\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.ARC) {\n      str += (command.relative ? \"a\" : \"A\") +\n        command.rX + WSP + command.rY +\n        WSP + command.xRot +\n        WSP + (+command.lArcFlag) + WSP + (+command.sweepFlag) +\n        WSP + command.x + WSP + command.y;\n    } else {\n      // Unknown command\n      throw new Error(\n        `Unexpected command type \"${ (command as any).type}\" at index ${i}.`);\n    }\n  }\n\n  return str;\n}\n","//# sourceMappingURL=./vara.js.map\r\nimport { SVGPathData } from \"svg-pathdata\"\r\n\r\ntype VaraGeneralOptions = {\r\n    fontSize?: number;\r\n    strokeWidth?: number;\r\n    color?: string;\r\n    duration?: number;\r\n    textAlign?: 'left' | 'center' | 'right';\r\n    autoAnimation?: boolean;\r\n    queued?: boolean;\r\n    delay?: number;\r\n    letterSpacing?:\r\n        | {\r\n              [x: string]: number;\r\n          }\r\n        | number;\r\n    breakWord?: boolean;\r\n    width?: number;\r\n};\r\n\r\ntype VaraTextOptions = VaraGeneralOptions & {\r\n    id?: string | number | false;\r\n    x?: number;\r\n    y?: number;\r\n    fromCurrentPosition?: {\r\n        x?: boolean;\r\n        y?: boolean;\r\n    };\r\n};\r\n\r\ntype VaraText = VaraTextOptions & {\r\n    text: string;\r\n};\r\n\r\ntype RenderData = VaraText & {\r\n    render?: {\r\n        text: string;\r\n        x: number;\r\n        y: number;\r\n    };\r\n};\r\n\r\ntype VaraFontItem = {\r\n    paths: Array<{\r\n        w: number;\r\n        h: number;\r\n        my: number;\r\n        mx: number;\r\n        pw: number;\r\n        d: string;\r\n    }>;\r\n    w: number;\r\n};\r\n\r\ntype ObjectKeys<T> = T extends object\r\n    ? (keyof T)[]\r\n    : T extends number\r\n    ? []\r\n    : T extends Array<any> | string\r\n    ? string[]\r\n    : never;\r\n\r\nclass Vara {\r\n    elementName: string;\r\n    element: HTMLElement;\r\n    fontSource: string;\r\n    options: VaraGeneralOptions;\r\n    textItems: VaraText[];\r\n    renderData: RenderData[];\r\n    rendered: boolean;\r\n    defaultOptions: Required<VaraGeneralOptions>;\r\n    defaultCharacters: {\r\n        [x: string]: VaraFontItem;\r\n    };\r\n    canvas: HTMLCanvasElement;\r\n    ctx: CanvasRenderingContext2D;\r\n    canvasWidth: number;\r\n    fontCharacters: {\r\n        [x: string]: VaraFontItem;\r\n    };\r\n    fontProperties!: {\r\n        s: number;\r\n        // TODO: add other properties\r\n        slc: 'round';\r\n        bsw: number;\r\n        lh: number;\r\n        space: number;\r\n        tf: number;\r\n    };\r\n\r\n    constructor(\r\n        elem: string,\r\n        fontSource: string,\r\n        text: VaraText[],\r\n        options: VaraGeneralOptions\r\n    ) {\r\n        this.elementName = elem;\r\n        this.element = document.querySelector(elem) as HTMLElement;\r\n        this.fontSource = fontSource;\r\n        this.options = options;\r\n        this.textItems = text;\r\n        this.renderData = text;\r\n        this.rendered = false;\r\n        this.fontCharacters = {};\r\n        this.canvasWidth = 0;\r\n\r\n        this.defaultOptions = {\r\n            fontSize: 21,\r\n            strokeWidth: 0.5,\r\n            color: '#000',\r\n            duration: 1000,\r\n            textAlign: 'left',\r\n            autoAnimation: true,\r\n            queued: true,\r\n            delay: 0,\r\n            breakWord: false,\r\n            letterSpacing: {\r\n                global: 0,\r\n            },\r\n            width: this.element.getBoundingClientRect().width,\r\n        };\r\n\r\n        this.defaultCharacters = {\r\n            '63': {\r\n                paths: [\r\n                    {\r\n                        w: 8.643798828125,\r\n                        h: 14.231731414794922,\r\n                        my: 22.666500004827977,\r\n                        mx: 0,\r\n                        pw: 28.2464542388916,\r\n                        d:\r\n                            'm 0,0 c -2,-6.01,5,-8.64,8,-3.98,2,4.09,-7,8.57,-7,11.85',\r\n                    },\r\n                    {\r\n                        w: 1.103759765625,\r\n                        h: 1.549820899963379,\r\n                        my: 8.881500004827977,\r\n                        mx: 1,\r\n                        pw: 4.466640472412109,\r\n                        d:\r\n                            'm 0,0 a 0.7592,0.7357,0,0,1,0,0.735,0.7592,0.7357,0,0,1,-1,-0.735,0.7592,0.7357,0,0,1,1,-0.738,0.7592,0.7357,0,0,1,0,0.738 z',\r\n                    },\r\n                ],\r\n                w: 8.643798828125,\r\n            },\r\n        };\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\r\n        this.element.appendChild(this.canvas);\r\n\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this.normalizeOptions();\r\n\r\n        const xmlhttp = new XMLHttpRequest();\r\n        xmlhttp.open('GET', this.fontSource, true);\r\n        xmlhttp.onreadystatechange = () => {\r\n            if (xmlhttp.readyState == 4) {\r\n                if (xmlhttp.status == 200) {\r\n                    const contents = JSON.parse(xmlhttp.responseText);\r\n                    this.fontCharacters = contents.c;\r\n                    this.fontProperties = contents.p;\r\n                    this.render();\r\n                }\r\n            }\r\n        };\r\n        xmlhttp.send(null);\r\n    }\r\n\r\n    render() {\r\n        this.calculatePositions(this.renderData[1]);\r\n        this.draw(this.renderData[1]);\r\n    }\r\n\r\n    draw(_textItem: RenderData) {\r\n        // path - \"d\": \"m 0,0 c 1.677946,-5.44834,5.875964,-14.09066,3.788545,-14.26551,-1.909719,-0.15996,-2.796112,9.62055,-3.788545,14.26551 z\"\r\n        const textItem = <Required<RenderData>>_textItem;\r\n        this.ctx.strokeStyle = textItem.color;\r\n        this.ctx.lineWidth = textItem.strokeWidth;\r\n        this.ctx.fillStyle = 'transparent';\r\n\r\n        textItem.render.text.split('').forEach(letter => {\r\n            let charCode = letter.charCodeAt(0);\r\n            if (this.fontCharacters[charCode])\r\n                this.fontCharacters[charCode].paths.forEach(path => {\r\n                    const svg = new SVGPathData(path.d);\r\n                    console.log(svg);\r\n                });\r\n        });\r\n    }\r\n\r\n    normalizeOptions() {\r\n        this.options = this.options || {};\r\n\r\n        this.objectKeys(this.defaultOptions).forEach(optionKey => {\r\n            if (this.options[optionKey] === undefined) {\r\n                // @ts-ignore\r\n                this.options[optionKey] = this.defaultOptions[optionKey];\r\n            }\r\n        });\r\n\r\n        this.renderData.forEach((textItem, i) => {\r\n            if (typeof textItem === 'string') {\r\n                this.renderData[i] = {\r\n                    text: textItem,\r\n                    ...this.defaultOptions,\r\n                };\r\n            } else if (typeof textItem === 'object') {\r\n                this.objectKeys(this.options).forEach(option => {\r\n                    if (textItem[option] === undefined)\r\n                        // @ts-ignore\r\n                        textItem[option] = this.options[option];\r\n                });\r\n            }\r\n        });\r\n\r\n        Object.keys(this.defaultCharacters).forEach(character => {\r\n            if (this.fontCharacters[character] === undefined) {\r\n                this.fontCharacters[character] = this.defaultCharacters[\r\n                    character\r\n                ];\r\n            }\r\n        });\r\n    }\r\n\r\n    calculatePositions(_textItem: RenderData) {\r\n        const textItem = <Required<RenderData>>_textItem;\r\n\r\n        if (!textItem.breakWord) {\r\n            const textBlock =\r\n                typeof textItem.text === 'string'\r\n                    ? [textItem.text]\r\n                    : textItem.text;\r\n\r\n            const breakedTextBlock = textBlock.map(line => {\r\n                return line.split(' ');\r\n            });\r\n\r\n            let lineWidth = 0;\r\n            const lines: string[] = [''];\r\n            breakedTextBlock.forEach(line => {\r\n                line.forEach(word => {\r\n                    let wordWidth = 0;\r\n\r\n                    word.split('').forEach(letter => {\r\n                        const charCode = letter.charCodeAt(0);\r\n\r\n                        const currentLetter =\r\n                            this.fontCharacters[charCode] ||\r\n                            this.fontCharacters['63'];\r\n\r\n                        wordWidth += currentLetter.w * (textItem.fontSize / 16);\r\n                    });\r\n\r\n                    if (lineWidth + wordWidth > textItem.width) {\r\n                        lineWidth = 0;\r\n                        lines.push(word);\r\n                    } else {\r\n                        lines[lines.length - 1] += word;\r\n                        lineWidth += wordWidth;\r\n                    }\r\n                    lines[lines.length - 1] += ' ';\r\n                });\r\n            });\r\n\r\n            lines.forEach(line => {\r\n                textItem.render = {\r\n                    text: line,\r\n                    x: textItem.x,\r\n                    y: textItem.y,\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    createSVGNode(n: string, v: { [x: string]: string }) {\r\n        const e = document.createElementNS('http://www.w3.org/2000/svg', n);\r\n        for (var p in v)\r\n            e.setAttributeNS(\r\n                null,\r\n                p.replace(/[A-Z]/g, function(m) {\r\n                    return '-' + m.toLowerCase();\r\n                }),\r\n                v[p]\r\n            );\r\n        return e;\r\n    }\r\n\r\n    objectKeys<T>(x: T) {\r\n        let keys = Object.keys(x) as ObjectKeys<T>;\r\n        return keys;\r\n    }\r\n}\r\n\r\nif (window) {\r\n    (<any>window).Vara = Vara;\r\n}\r\n"],"names":["rotate","_a","rad","x","y","Math","cos","sin","assertNumbers","_i","numbers","i","length","Error","PI","annotateArcCommand","c","x1","y1","lArcFlag","sweepFlag","rX","rY","abs","x1_","y1_","testValue","pow","sqrt","c_ScaleTemp","c_Scale","max","cx_","cy_","cRot","xRot","cX","cY","phi1","atan2","phi2","intersectionUnitCircleLine","a","b","termSqr","term","SVGPathDataTransformer","DEG","lerp","t","arcAt","x2","phiDeg","bezierRoot","x0","x3","x01","x12","p","q","PRECISION","discriminantX4","root","bezierAt","s","TO_ABS","INFO","command","prevX","prevY","relative","y2","NORMALIZE_ST","prevCurveC2X","NaN","prevCurveC2Y","prevQuadCX","prevQuadCY","type","SVGPathData","SMOOTH_CURVE_TO","CURVE_TO","isNaN","SMOOTH_QUAD_TO","QUAD_TO","QT_TO_C","prevQuadX1","prevQuadY1","f","prevXAbs","prevYAbs","pathStartXAbs","pathStartYAbs","MOVE_TO","result","CLOSE_PATH","MATRIX","d","e","pathStartX","origX1","origX2","comRel","sqr","HORIZ_LINE_TO","LINE_TO","VERT_LINE_TO","det","sinRot","cosRot","xCurve","yCurve","A","B","C","A1","B1","C1","newXRot","newSinRot","newCosRot","roundVal","rf","val","round","normalizeZ","normalizeH","normalizeV","pathStartY","ARC","EPS","skip","x1Rel","y1Rel","LINE_COMMANDS","xRel","yRel","x2Rel","y2Rel","dX","dY","atan","xOffset","yOffset","arc","y0","phiMin","min","deltaPhi","partCount","ceil","Array","phiStart","phiEnd","tan","_e","_f","_g","transform","_b","_c","_d","key","toAbs","qtToC","normST","clone","fixX","absX","maxX","minX","fixY","absY","maxY","minY","DRAWING_COMMANDS","xDerivRoots_1","derivRoot","yDerivRoots_1","xRotRad","x90","y90","phiMin_1","phiMax","normalizeXiEta","phi","xDerivRoots_2","map","yDerivRoots_2","Infinity","TransformableSVG","this","ROUND","TO_REL","NORMALIZE_HVZ","A_TO_C","eps","SANITIZE","TRANSLATE","SCALE","ROTATE","SKEW_X","SKEW_Y","X_AXIS_SYMMETRY","Y_AXIS_SYMMETRY","ANNOTATE_ARCS","isWhiteSpace","isDigit","charCodeAt","_super","_this","__extends","SVGPathDataParser","commands","parse","curArgs","canParseCommandOrComma","SyntaxError","str","finishCommand","push","isAArcFlag","curCommandType","curNumber","isEndingDigit","curNumberHasExp","curNumberHasExpDigits","curNumberHasDecimal","Number","COMMAND_ARG_COUNTS","curCommandRelative","Object","create","value","chunk","parsedCommands_1","getPrototypeOf","call","cT","isArray","content","encode","boundsTransform","CALCULATE_BOUNDS","transformFunction","newCommands","transformedCommand","encodeSVGPath","path","parser","finish","window","Vara","elem","fontSource","text","options","elementName","element","document","querySelector","textItems","renderData","rendered","fontCharacters","canvasWidth","defaultOptions","fontSize","strokeWidth","color","duration","textAlign","autoAnimation","queued","delay","breakWord","letterSpacing","global","width","getBoundingClientRect","defaultCharacters","paths","w","h","my","mx","pw","canvas","createElement","ctx","getContext","appendChild","init","normalizeOptions","xmlhttp","XMLHttpRequest","open","onreadystatechange","readyState","status","contents","JSON","responseText","fontProperties","render","send","calculatePositions","draw","_textItem","textItem","strokeStyle","lineWidth","fillStyle","split","forEach","letter","charCode","_this2","svg","console","log","objectKeys","optionKey","undefined","_this3","option","keys","character","breakedTextBlock","line","lines","word","wordWidth","_this4","createSVGNode","n","v","createElementNS","setAttributeNS","replace","m","toLowerCase"],"mappings":"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"}